

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bitvis VIP SPI &mdash; UVVM  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bitvis VIP UART" href="vip_uart.html" />
    <link rel="prev" title="Bitvis VIP Specification Coverage" href="vip_spec_cov.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #F5F5F5" >

          
          
          <a href="index.html">
            
              <img src="_static/uvvm.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="uvvm_intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uvvm_getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="utility_library.html">Utility Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="uvvm_assertions.html">UVVM Assertions (BETA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="rand_pkg_overview.html">Enhanced Randomization</a></li>
<li class="toctree-l1"><a class="reference internal" href="func_cov_pkg_overview.html">Functional Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimized_rand.html">Optimized Randomization</a></li>
<li class="toctree-l1"><a class="reference internal" href="vvc_framework.html">VVC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="fifo_collection.html">UVVM FIFO Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_queue.html">UVVM Generic Queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_avalon_mm.html">Bitvis VIP Avalon-MM</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_avalon_st.html">Bitvis VIP Avalon-ST</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axi.html">Bitvis VIP AXI4</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axilite.html">Bitvis VIP AXI4-Lite</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axistream.html">Bitvis VIP AXI4-Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_clock_generator.html">Bitvis VIP Clock Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_error_injection.html">Bitvis VIP Error Injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_ethernet.html">Bitvis VIP Ethernet</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_gmii.html">Bitvis VIP GMII</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_gpio.html">Bitvis VIP GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_hvvc_to_vvc_bridge.html">Bitvis VIP HVVC-to-VVC Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_i2c.html">Bitvis VIP I2C</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_rgmii.html">Bitvis VIP RGMII</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_sbi.html">Bitvis VIP SBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_scoreboard.html">Bitvis VIP Scoreboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_spec_cov.html">Bitvis VIP Specification Coverage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Bitvis VIP SPI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bfm">BFM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signal-record">Signal Record</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-record">Configuration Record</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methods">Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit-and-receive">spi_master_transmit_and_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit-and-check">spi_master_transmit_and_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit">spi_master_transmit()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-receive">spi_master_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-check">spi_master_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit-and-receive">spi_slave_transmit_and_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit-and-check">spi_slave_transmit_and_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit">spi_slave_transmit()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-receive">spi_slave_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-check">spi_slave_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-spi-if-signals">init_spi_if_signals()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#local-bfm-overloads">Local BFM overloads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-bfm-configuration">Local BFM configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compilation">Compilation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simulator-compatibility-and-setup">Simulator compatibility and setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#additional-documentation">Additional Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vvc">VVC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#entity">Entity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generics">Generics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Configuration Record</a></li>
<li class="toctree-l3"><a class="reference internal" href="#status-record">Status Record</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit-and-receive-vvc">spi_master_transmit_and_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit-only">spi_master_transmit_only()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-receive-only">spi_master_receive_only()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-transmit-and-check-vvc">spi_master_transmit_and_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-check-only">spi_master_check_only()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit-and-receive-vvc">spi_slave_transmit_and_receive()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit-only">spi_slave_transmit_only()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-receive-only">spi_slave_receive_only()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-transmit-and-check-vvc">spi_slave_transmit_and_check()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-slave-check-only">spi_slave_check_only()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#activity-watchdog">Activity Watchdog</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transaction-info">Transaction Info</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scoreboard">Scoreboard</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unwanted-activity-detection">Unwanted Activity Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Compilation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">Simulator compatibility and setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id9">Additional Documentation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vip_uart.html">Bitvis VIP UART</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_wishbone.html">Bitvis VIP Wishbone</a></li>
<li class="toctree-l1"><a class="reference internal" href="tool_compatibility.html">Tool Compatibility</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #F5F5F5" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">UVVM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Bitvis VIP SPI</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/vip_spi.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bitvis-vip-spi">
<h1>Bitvis VIP SPI<a class="headerlink" href="#bitvis-vip-spi" title="Link to this heading"></a></h1>
<p><strong>Quick Access</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#bfm">BFM</a></p>
<ul>
<li><p><a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-transmit-and-check-bfm"><span class="std std-ref">spi_master_transmit_and_check()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-transmit-bfm"><span class="std std-ref">spi_master_transmit()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-receive-bfm"><span class="std std-ref">spi_master_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-check-bfm"><span class="std std-ref">spi_master_check()</span></a></p></li>
<li><p><a class="reference internal" href="#init-spi-if-signals-bfm"><span class="std std-ref">init_spi_if_signals()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-and-check-bfm"><span class="std std-ref">spi_slave_transmit_and_check()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-bfm"><span class="std std-ref">spi_slave_transmit()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-receive-bfm"><span class="std std-ref">spi_slave_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-check-bfm"><span class="std std-ref">spi_slave_check()</span></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vvc">VVC</a></p>
<ul>
<li><p><a class="reference internal" href="#spi-master-transmit-and-receive-vvc"><span class="std std-ref">spi_master_transmit_and_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-transmit-and-check-vvc"><span class="std std-ref">spi_master_transmit_and_check()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-transmit-only-vvc"><span class="std std-ref">spi_master_transmit_only()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-receive-only-vvc"><span class="std std-ref">spi_master_receive_only()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-master-check-only-vvc"><span class="std std-ref">spi_master_check_only()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-and-receive-vvc"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-and-check-vvc"><span class="std std-ref">spi_slave_transmit_and_check()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-transmit-only-vvc"><span class="std std-ref">spi_slave_transmit_only()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-receive-only-vvc"><span class="std std-ref">spi_slave_receive_only()</span></a></p></li>
<li><p><a class="reference internal" href="#spi-slave-check-only-vvc"><span class="std std-ref">spi_slave_check_only()</span></a></p></li>
</ul>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<hr class="docutils" />
<section id="bfm">
<h2>BFM<a class="headerlink" href="#bfm" title="Link to this heading"></a></h2>
<p>BFM functionality is implemented in spi_bfm_pkg.vhd</p>
<section id="signal-record">
<span id="t-spi-if"></span><h3>Signal Record<a class="headerlink" href="#signal-record" title="Link to this heading"></a></h3>
<p><strong>t_spi_if</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Record element</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ss_n</p></td>
<td><p>std_logic</p></td>
</tr>
<tr class="row-odd"><td><p>sclk</p></td>
<td><p>std_logic</p></td>
</tr>
<tr class="row-even"><td><p>mosi</p></td>
<td><p>std_logic</p></td>
</tr>
<tr class="row-odd"><td><p>miso</p></td>
<td><p>std_logic</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some BFM calls can also be made with listing of single signals rather than t_spi_if.</p>
</div>
</section>
<section id="configuration-record">
<span id="t-spi-bfm-config"></span><h3>Configuration Record<a class="headerlink" href="#configuration-record" title="Link to this heading"></a></h3>
<p><strong>t_spi_bfm_config</strong></p>
<p>Default value for the record is C_SPI_BFM_CONFIG_DEFAULT.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Record element</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CPOL</p></td>
<td><p>std_logic</p></td>
<td><p>‘0’</p></td>
<td><p>sclk polarity, i.e. the base value of the clock.
If CPOL is ‘0’, the clock will be set to ‘0’
when inactive, i.e., positive polarity.</p></td>
</tr>
<tr class="row-odd"><td><p>CPHA</p></td>
<td><p>std_logic</p></td>
<td><p>‘0’</p></td>
<td><p>sclk phase, i.e. when data is sampled and
transmitted w.r.t. sclk. If ‘0’, sampling occurs
on the first sclk edge and data is transmitted
on the sclk active to idle state. If ‘1’, data
is sampled on the second sclk edge and
transmitted on sclk idle to active state.</p></td>
</tr>
<tr class="row-even"><td><p>spi_bit_time</p></td>
<td><p>time</p></td>
<td><p>-1 ns</p></td>
<td><p>Used in master for dictating the sclk period.
Will give a TB_ERROR if not set to a different
value than -1.</p></td>
</tr>
<tr class="row-odd"><td><p>ss_n_to_sclk</p></td>
<td><p>time</p></td>
<td><p>20 ns</p></td>
<td><p>Time from ss_n low until sclk active</p></td>
</tr>
<tr class="row-even"><td><p>sclk_to_ss_n</p></td>
<td><p>time</p></td>
<td><p>20 ns</p></td>
<td><p>Time from last sclk until ss_n is released</p></td>
</tr>
<tr class="row-odd"><td><p>inter_word_delay</p></td>
<td><p>time</p></td>
<td><p>0 ns</p></td>
<td><p>Minimum time between words, from ss_n inactive
to ss_n active</p></td>
</tr>
<tr class="row-even"><td><p>match_strictness</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-match-strictness"><span class="std std-ref">t_match_strictness</span></a></p></td>
<td><p>MATCH_EXACT</p></td>
<td><p>Matching strictness for std_logic values in
check procedures.</p>
<p>MATCH_EXACT requires both values to be the
same. Note that the expected value can contain
the don’t care operator ‘-‘.</p>
<p>MATCH_STD allows comparisons between ‘H’ and
‘1’, ‘L’ and ‘0’ and ‘-’ in both values.</p>
</td>
</tr>
<tr class="row-odd"><td><p>id_for_bfm</p></td>
<td><p>t_msg_id</p></td>
<td><p>ID_BFM</p></td>
<td><p>Message ID used for logging general messages in
the BFM</p></td>
</tr>
<tr class="row-even"><td><p>id_for_bfm_wait</p></td>
<td><p>t_msg_id</p></td>
<td><p>ID_BFM_WAIT</p></td>
<td><p>DEPRECATED</p></td>
</tr>
<tr class="row-odd"><td><p>id_for_bfm_poll</p></td>
<td><p>t_msg_id</p></td>
<td><p>ID_BFM_POLL</p></td>
<td><p>DEPRECATED</p></td>
</tr>
</tbody>
</table>
</section>
<section id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>The record <a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a> can be replaced with the signals listed in said record in some methods.</p></li>
<li><p>All signals are active high.</p></li>
<li><p>All parameters in brackets are optional.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The BFM configuration has to be defined and used when calling the SPI BFM procedures. See <a class="reference internal" href="#spi-local-bfm-config"><span class="std std-ref">Local BFM configuration</span></a> for an
example of how to define a local BFM config.</p>
</div>
<section id="spi-master-transmit-and-receive">
<span id="spi-master-transmit-and-receive-bfm"></span><h4>spi_master_transmit_and_receive()<a class="headerlink" href="#spi-master-transmit-and-receive" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ to the DUT and stores the received data in ‘rx_data’, using the SPI protocol. For protocol details,
see the SPI specification.</p>
<p>When called, the procedure will set ss_n low. For a slave DUT to be able to transmit to a receiving master BFM, the master BFM
must drive the sclk and ss_n signals and transmit data to the slave DUT.</p>
<ul class="simple">
<li><p>This procedure is responsible for driving sclk and ss_n.</p></li>
<li><p>The SPI bit timing is given by config.spi_bit_time, config.spi_ss_n_to_sclk and config.sclk_to_ss_n.</p></li>
<li><p>An error is reported if ss_n is not kept low during the entire transmission.</p></li>
<li><p>Note that action_between_words only apply for t_slv_array multi-word transfers.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>variable</p></td>
<td><p>rx_data</p></td>
<td><p>out</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value received from the DUT, either a single
word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1 and receiving data back&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1 and receiving data back&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span>
<span class="w">                                </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A to DUT and receiving data from DUT&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-transmit-and-check">
<span id="spi-master-transmit-and-check-bfm"></span><h4>spi_master_transmit_and_check()<a class="headerlink" href="#spi-master-transmit-and-check" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ and receives data from the DUT, using the transmit and receive procedure as described in
<a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a>. After receiving data, the data is compared with the expected data.</p>
<ul class="simple">
<li><p>If the check was successful, and the received data matches the expected data, a log message is written with ID ‘config.id_for_bfm’.</p></li>
<li><p>If the received data did not match the expected data, an alert with severity ‘alert_level’ will be reported.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a> procedure.</p></li>
<li><p>Note that action_between_words only apply for t_slv_array multi-word transfers.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data and checking received data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;3A&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting data and checking received data on SPI interface&quot;</span><span class="p">,</span>
<span class="w">                              </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span>
<span class="w">                              </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">C_CR_BYTE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting 0xAA and expecting carriage return&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-transmit">
<span id="spi-master-transmit-bfm"></span><h4>spi_master_transmit()<a class="headerlink" href="#spi-master-transmit" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ using the transmit and receive procedure as described in <a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a>.</p>
<ul class="simple">
<li><p>The received data from the DUT is ignored.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a> procedure.</p></li>
<li><p>Note that action_between_words only apply for t_slv_array multi-word transfers.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_master_transmit</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_master_transmit</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span>
<span class="w">                    </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_master_transmit</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A to DUT&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-receive">
<span id="spi-master-receive-bfm"></span><h4>spi_master_receive()<a class="headerlink" href="#spi-master-receive" title="Link to this heading"></a></h4>
<p>Receives data from the DUT using the transmit and receive procedure as described in <a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a>.</p>
<ul class="simple">
<li><p>The procedure will transmit dummy data (0x0) to the DUT.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a> procedure.</p></li>
<li><p>Note that action_between_words only apply for t_slv_array multi-word transfers.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_receive</span><span class="p">(</span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_master_receive</span><span class="p">(</span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>variable</p></td>
<td><p>rx_data</p></td>
<td><p>out</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value received from the DUT, either a single
word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_master_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span>
<span class="w">                   </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_master_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-check">
<span id="spi-master-check-bfm"></span><h4>spi_master_check()<a class="headerlink" href="#spi-master-check" title="Link to this heading"></a></h4>
<p>Receives data from the DUT, using the transmit and receive procedure as described in <a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a>.
After receiving data, the data is compared with the expected data.</p>
<ul class="simple">
<li><p>If the check was successful, and the received data matches the expected data, a log message is written with ID ‘config.id_for_bfm’.</p></li>
<li><p>If the received data did not match the expected data, an alert with severity ‘alert_level’ will be reported.</p></li>
<li><p>The procedure will transmit dummy data (0x0) to the DUT.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a> procedure.</p></li>
<li><p>Note that action_between_words only apply for t_slv_array multi-word transfers.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_check</span><span class="p">(</span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
<span class="n">spi_master_check</span><span class="p">(</span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_check</span><span class="p">(</span><span class="mh">x&quot;3B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Checking data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_master_check</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Checking data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span>
<span class="w">                 </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_master_check</span><span class="p">(</span><span class="n">C_CR_BYTE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting carriage return&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-transmit-and-receive">
<span id="spi-slave-transmit-and-receive-bfm"></span><h4>spi_slave_transmit_and_receive()<a class="headerlink" href="#spi-slave-transmit-and-receive" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ to the DUT and stores the received data in ‘rx_data’, using the SPI protocol. For protocol details,
see the SPI specification.</p>
<p>When called, the procedure will wait for next ss_n, or start transfer and receive immediately, depending on the selection of
when_to_start_transfer and if ss_n is already set. If terminate_access is ‘1’ when this happens, the transfer and receive will be
terminated instead.</p>
<ul class="simple">
<li><p>An error is reported if ss_n is not kept low during the entire transmission.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">tx_data</span><span class="p">,</span><span class="w"> </span><span class="n">rx_data</span><span class="p">,</span><span class="w"> </span><span class="n">aborted</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">aborted_alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">tx_data</span><span class="p">,</span><span class="w"> </span><span class="n">rx_data</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>variable</p></td>
<td><p>rx_data</p></td>
<td><p>out</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value received from the DUT, either a single
word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>variable</p></td>
<td><p>aborted</p></td>
<td><p>out</p></td>
<td><p>boolean</p></td>
<td><p>Set to true when the procedure is aborted</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>terminate_access</p></td>
<td><p>in</p></td>
<td><p>std_logic</p></td>
<td><p>Determines if SPI slave transfer is performed. Setting
this to ‘1’ before a slave command is executed
terminates the command.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>aborted_alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert when the procedure is
aborted. Default value is ERROR.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting and receiving data from peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting and receiving data from peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span>
<span class="w">                               </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A to DUT and receiving data from DUT&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-transmit-and-check">
<span id="spi-slave-transmit-and-check-bfm"></span><h4>spi_slave_transmit_and_check()<a class="headerlink" href="#spi-slave-transmit-and-check" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ and receives data from the DUT, using the transmit and receive procedure as described in
<a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a>. After receiving data, the data is compared with the expected data.</p>
<ul class="simple">
<li><p>If the check was successful, and the received data matches the expected data, a log message is written with ID ‘config.id_for_bfm’.</p></li>
<li><p>If the received data did not match the expected data, an alert with severity ‘alert_level’ will be reported.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a> procedure.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="n">tx_data</span><span class="p">,</span><span class="w"> </span><span class="n">data_exp</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>terminate_access</p></td>
<td><p>in</p></td>
<td><p>std_logic</p></td>
<td><p>Determines if SPI slave transfer is performed. Setting
this to ‘1’ before a slave command is executed
terminates the command.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data and checking received data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_slave_transmit_and_check</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;3A&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting data and checking received data on SPI interface&quot;</span><span class="p">,</span>
<span class="w">                              </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span>
<span class="w">                              </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">C_CR_BYTE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting 0xAA and expecting carriage return&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-transmit">
<span id="spi-slave-transmit-bfm"></span><h4>spi_slave_transmit()<a class="headerlink" href="#spi-slave-transmit" title="Link to this heading"></a></h4>
<p>Transmits the data in ‘tx_data’ using the transmit and receive procedure as described in <a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a>.</p>
<ul class="simple">
<li><p>The received data from the DUT is ignored.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a> procedure.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">aborted</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_slave_transmit</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_slave_transmit</span><span class="p">(</span><span class="n">tx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>tx_data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>variable</p></td>
<td><p>aborted</p></td>
<td><p>out</p></td>
<td><p>boolean</p></td>
<td><p>Set to true when the procedure is aborted</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>terminate_access</p></td>
<td><p>in</p></td>
<td><p>std_logic</p></td>
<td><p>Determines if SPI slave transfer is performed. Setting
this to ‘1’ before a slave command is executed
terminates the command.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit</span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_slave_transmit</span><span class="p">((</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting data to peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span>
<span class="w">                   </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_slave_transmit</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A to DUT&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-receive">
<span id="spi-slave-receive-bfm"></span><h4>spi_slave_receive()<a class="headerlink" href="#spi-slave-receive" title="Link to this heading"></a></h4>
<p>Receives data from the DUT using the transmit and receive procedure as described in <a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a>.</p>
<ul class="simple">
<li><p>The procedure will transmit dummy data (0x0) to the DUT.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a> procedure.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">aborted</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
<span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">rx_data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>variable</p></td>
<td><p>rx_data</p></td>
<td><p>out</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value received from the DUT, either a single
word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>variable</p></td>
<td><p>aborted</p></td>
<td><p>out</p></td>
<td><p>boolean</p></td>
<td><p>Set to true when the procedure is aborted</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>terminate_access</p></td>
<td><p>in</p></td>
<td><p>std_logic</p></td>
<td><p>Determines if SPI slave transfer is performed. Setting
this to ‘1’ before a slave command is executed
terminates the command.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span>
<span class="w">                  </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_slave_receive</span><span class="p">(</span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receive from Peripheral 1&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-check">
<span id="spi-slave-check-bfm"></span><h4>spi_slave_check()<a class="headerlink" href="#spi-slave-check" title="Link to this heading"></a></h4>
<p>Receives data from the DUT using the transmit and receive procedure as described in <a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a>.
After receiving data, the data is compared with the expected data.</p>
<ul class="simple">
<li><p>If the check was successful, and the received data matches the expected data, a log message is written with ID ‘config.id_for_bfm’.</p></li>
<li><p>If the received data did not match the expected data, an alert with severity ‘alert_level’ will be reported.</p></li>
<li><p>The procedure will transmit dummy data (0x0) to the DUT.</p></li>
<li><p>The procedure will report alerts for the same conditions and use similar default values as the
<a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a> procedure.</p></li>
</ul>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_check</span><span class="p">(</span><span class="n">data_exp</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">terminate_access</span><span class="p">,]</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">config</span><span class="p">]]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
<tr class="row-odd"><td><p>signal</p></td>
<td><p>terminate_access</p></td>
<td><p>in</p></td>
<td><p>std_logic</p></td>
<td><p>Determines if SPI slave transfer is performed. Setting
this to ‘1’ before a slave command is executed
terminates the command.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_BFM_SCOPE (“SPI BFM”).</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id_panel</p></td>
<td><p>in</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>Controls verbosity within a specified scope. Default
value is shared_msg_id_panel.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions. Default
value is C_SPI_BFM_CONFIG_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_check</span><span class="p">(</span><span class="mh">x&quot;3B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Checking data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">);</span>
<span class="n">spi_slave_check</span><span class="p">((</span><span class="mh">x&quot;3A&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Checking data on SPI interface&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">terminate_access</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span>
<span class="w">                </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span>

<span class="c1">-- Suggested usage (requires local overload, see &#39;Local BFM overloads&#39; section):</span>
<span class="n">spi_slave_check</span><span class="p">(</span><span class="n">C_CR_BYTE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting carriage return&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="init-spi-if-signals">
<span id="init-spi-if-signals-bfm"></span><h4>init_spi_if_signals()<a class="headerlink" href="#init-spi-if-signals" title="Link to this heading"></a></h4>
<p>Initializes the SPI interface.</p>
<dl class="simple">
<dt>Master mode set true:</dt><dd><ul class="simple">
<li><p>ss_n initialized to ‘H’.</p></li>
<li><p>if config.CPOL = ‘1’, sclk initialized to ‘H’. Otherwise, sclk initialized to ‘L’.</p></li>
<li><p>miso and mosi initialized to ‘Z’.</p></li>
</ul>
</dd>
<dt>Master mode set false:</dt><dd><ul class="simple">
<li><p>All signals initialized to ‘Z’.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">t_spi_if</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">init_spi_if_signals</span><span class="p">(</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">master_mode</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>constant</p></td>
<td><p>config</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>Configuration of BFM behavior and restrictions</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>master_mode</p></td>
<td><p>in</p></td>
<td><p>boolean</p></td>
<td><p>Whether the interface is in master or slave mode.
Default value is true (master).</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_if</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">init_spi_if_signals</span><span class="p">(</span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">);</span><span class="w">        </span><span class="c1">-- Implicitly master mode since default is &#39;true&#39;</span>
<span class="n">spi_if</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">init_spi_if_signals</span><span class="p">(</span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="n">true</span><span class="p">);</span><span class="w">  </span><span class="c1">-- Explicitly indicating master mode</span>
<span class="n">spi_if</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">init_spi_if_signals</span><span class="p">(</span><span class="n">C_SPI_BFM_CONFIG_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="n">false</span><span class="p">);</span><span class="w"> </span><span class="c1">-- master_mode is false, i.e., shall act as a slave</span>
</pre></div>
</div>
</section>
</section>
<section id="local-bfm-overloads">
<h3>Local BFM overloads<a class="headerlink" href="#local-bfm-overloads" title="Link to this heading"></a></h3>
<p>A good approach for better readability and maintainability is to make simple, local overloads for the BFM procedures in the TB
process. This allows calling the BFM procedures with the key parameters only, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>rather than</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">C_ASCII_A</span><span class="p">,</span><span class="w"> </span><span class="n">v_data_out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting ASCII A&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi_if</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w"> </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w"> </span><span class="n">C_SPI_CONFIG_LOCAL</span><span class="p">);</span>
</pre></div>
</div>
<p>By defining the local overload as e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span><span class="w"> </span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">tx_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w">  </span><span class="kt">std_logic_vector</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">rx_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">msg</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w">  </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="k">is</span>
<span class="k">begin</span>
<span class="w">  </span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">tx_data</span><span class="p">,</span><span class="w">                     </span><span class="c1">-- Keep as is</span>
<span class="w">                                  </span><span class="n">rx_data</span><span class="p">,</span><span class="w">                     </span><span class="c1">-- Keep as is</span>
<span class="w">                                  </span><span class="n">msg</span><span class="p">,</span><span class="w">                         </span><span class="c1">-- Keep as is</span>
<span class="w">                                  </span><span class="n">spi_if</span><span class="p">,</span><span class="w">                      </span><span class="c1">-- Signal must be visible in local process scope</span>
<span class="w">                                  </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="c1">-- Use default, unless passing SLVs to master in a multi-word transfer</span>
<span class="w">                                  </span><span class="n">C_SCOPE</span><span class="p">,</span><span class="w">                     </span><span class="c1">-- Use the default</span>
<span class="w">                                  </span><span class="n">shared_msg_id_panel</span><span class="p">,</span><span class="w">         </span><span class="c1">-- Use global, shared msg_id_panel</span>
<span class="w">                                  </span><span class="n">C_SPI_CONFIG_LOCAL</span><span class="p">);</span><span class="w">         </span><span class="c1">-- Use locally defined configuration or C_SPI_CONFIG_DEFAULT</span>
<span class="k">end</span><span class="w"> </span><span class="k">procedure</span><span class="p">;</span>
</pre></div>
</div>
<p>Using a local overload like this also allows the following – if wanted:</p>
<ul class="simple">
<li><p>Set up defaults for constants. May be different for two overloads of the same BFM</p></li>
<li><p>Apply dedicated message ID panel to allow dedicated verbosity control</p></li>
</ul>
</section>
<section id="local-bfm-configuration">
<span id="spi-local-bfm-config"></span><h3>Local BFM configuration<a class="headerlink" href="#local-bfm-configuration" title="Link to this heading"></a></h3>
<p>The SPI BFM requires that a local configuration is declared in the testbench and used in the BFM procedure calls. The default BFM
configuration is defined with a bit period of -1 ns so that the BFM can detect and alert the user that the configuration has not
been set.</p>
<p>Defining a local SPI BFM configuration::</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">C_SPI_CONFIG_LOCAL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t_spi_bfm_config</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">CPOL</span><span class="w">             </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="n">CPHA</span><span class="w">             </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="n">spi_bit_time</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="n">ns</span><span class="p">,</span>
<span class="w">  </span><span class="n">ss_n_to_sclk</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">301</span><span class="w"> </span><span class="n">ns</span><span class="p">,</span>
<span class="w">  </span><span class="n">sclk_to_ss_n</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">301</span><span class="w"> </span><span class="n">ns</span><span class="p">,</span>
<span class="w">  </span><span class="n">inter_word_delay</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ns</span><span class="p">,</span>
<span class="w">  </span><span class="n">match_strictness</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MATCH_EXACT</span><span class="p">,</span>
<span class="w">  </span><span class="n">id_for_bfm</span><span class="w">       </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ID_BFM</span><span class="p">,</span>
<span class="w">  </span><span class="n">id_for_bfm_wait</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ID_BFM_WAIT</span><span class="p">,</span>
<span class="w">  </span><span class="n">id_for_bfm_poll</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ID_BFM_POLL</span>
<span class="p">);</span>
</pre></div>
</div>
</section>
<section id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>This BFM package may only be compiled with VHDL-2008 or newer. It is dependent on the <a class="reference internal" href="utility_library.html#utility-library"><span class="std std-ref">Utility Library</span></a>, which is only
compatible with VHDL-2008 or newer.</p></li>
<li><p>After UVVM-Util has been compiled, the BFM package can be compiled into any desired library.</p></li>
<li><p>See <a class="reference internal" href="vvc_framework.html#vvc-framework-compile-scripts"><span class="std std-ref">Essential Mechanisms - Compile Scripts</span></a> for information about compile scripts.</p></li>
</ul>
<section id="simulator-compatibility-and-setup">
<h4>Simulator compatibility and setup<a class="headerlink" href="#simulator-compatibility-and-setup" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>See <a class="reference internal" href="uvvm_intro.html#uvvm-prerequisites"><span class="std std-ref">Prerequisites</span></a> for a list of supported simulators.</p></li>
<li><p>For required simulator setup see <a class="reference internal" href="utility_library.html#util-simulator-compatibility"><span class="std std-ref">UVVM-Util Simulator compatibility and setup</span></a>.</p></li>
</ul>
</section>
</section>
<section id="additional-documentation">
<h3>Additional Documentation<a class="headerlink" href="#additional-documentation" title="Link to this heading"></a></h3>
<p>For additional documentation on the SPI protocol, please see the SPI specification, e.g. “ST TN0897 Technical note ST SPI protocol.
ID 023176 Rev 2”.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul class="simple">
<li><p>This is a simplified Bus Functional Model (BFM) for SPI.</p></li>
<li><p>The given BFM complies with the basic SPI protocol and thus allows a normal access towards a SPI interface.</p></li>
<li><p>This BFM is not a SPI protocol checker.</p></li>
<li><p>For a more advanced BFM please contact UVVM support at <a class="reference external" href="mailto:info&#37;&#52;&#48;uvvm&#46;org">info<span>&#64;</span>uvvm<span>&#46;</span>org</a></p></li>
</ul>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="vvc">
<h2>VVC<a class="headerlink" href="#vvc" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>VVC functionality is implemented in spi_vvc.vhd</p></li>
<li><p>For general information see <a class="reference internal" href="vvc_framework.html#vvc-framework-essential-mechanisms"><span class="std std-ref">VVC Framework - Essential Mechanisms</span></a>.</p></li>
</ul>
<section id="entity">
<h3>Entity<a class="headerlink" href="#entity" title="Link to this heading"></a></h3>
<section id="generics">
<h4>Generics<a class="headerlink" href="#generics" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>GC_DATA_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>8</p></td>
<td><p>Bits in the SPI data word</p></td>
</tr>
<tr class="row-odd"><td><p>GC_DATA_ARRAY_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>Number of SPI data words in a data word array of
type t_slv_array</p></td>
</tr>
<tr class="row-even"><td><p>GC_INSTANCE_IDX</p></td>
<td><p>natural</p></td>
<td><p>1</p></td>
<td><p>Instance number to assign the VVC</p></td>
</tr>
<tr class="row-odd"><td><p>GC_MASTER_MODE</p></td>
<td><p>boolean</p></td>
<td><p>true</p></td>
<td><p>Whether the VVC shall act as an SPI master or
an SPI slave on the bus</p></td>
</tr>
<tr class="row-even"><td><p>GC_SPI_CONFIG</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>C_SPI_BFM_CONFIG_DEFAULT</p></td>
<td><p>Configuration for the SPI BFM</p></td>
</tr>
<tr class="row-odd"><td><p>GC_CMD_QUEUE_COUNT_MAX</p></td>
<td><p>natural</p></td>
<td><p>C_CMD_QUEUE_COUNT_MAX</p></td>
<td><p>Absolute maximum number of commands in the VVC
command queue</p></td>
</tr>
<tr class="row-even"><td><p>GC_CMD_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>natural</p></td>
<td><p>C_CMD_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>An alert will be generated when reaching this
threshold to indicate that the command queue is
almost full. The queue will still accept new commands until it reaches GC_CMD_QUEUE_COUNT_MAX.</p></td>
</tr>
<tr class="row-odd"><td><p>GC_CMD_QUEUE_COUNT_THRESHOLD_SEVERITY</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>C_CMD_QUEUE_COUNT_THRESHOLD_SEVERITY</p></td>
<td><p>Alert severity which will be used when command
queue reaches GC_CMD_QUEUE_COUNT_THRESHOLD</p></td>
</tr>
<tr class="row-even"><td><p>GC_RESULT_QUEUE_COUNT_MAX</p></td>
<td><p>natural</p></td>
<td><p>C_RESULT_QUEUE_COUNT_MAX</p></td>
<td><p>Maximum number of unfetched results before
result_queue is full</p></td>
</tr>
<tr class="row-odd"><td><p>GC_RESULT_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>natural</p></td>
<td><p>C_RESULT_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>An alert will be issued if result queue exceeds
this count. Used for early warning if result
queue is almost full. Will be ignored if set to
0.</p></td>
</tr>
<tr class="row-even"><td><p>GC_RESULT_QUEUE_COUNT_THRESHOLD_SEVERITY</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>C_RESULT_QUEUE _COUNT_THRESHOLD_SEVERITY</p></td>
<td><p>Severity of alert to be initiated if exceeding
GC_RESULT_QUEUE_COUNT_THRESHOLD</p></td>
</tr>
</tbody>
</table>
</section>
<section id="signals">
<h4>Signals<a class="headerlink" href="#signals" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>spi_vvc_if</p></td>
<td><p>inout</p></td>
<td><p><a class="reference internal" href="#t-spi-if"><span class="std std-ref">t_spi_if</span></a></p></td>
<td><p>SPI signal interface record</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id1">
<h3>Configuration Record<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p><strong>vvc_config</strong> accessible via <strong>shared_spi_vvc_config</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Record element</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>inter_bfm_delay</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-inter-bfm-delay"><span class="std std-ref">t_inter_bfm_delay</span></a></p></td>
<td><p>C_SPI_INTER_BFM_DELAY_DEFAULT</p></td>
<td><p>Delay between any requested BFM accesses
towards the DUT.</p>
<p>TIME_START2START: Time from a BFM start to the
next BFM start (a TB_WARNING will be issued if
access takes longer than TIME_START2START).</p>
<p>TIME_FINISH2START: Time from a BFM end to the
next BFM start.</p>
<p>Any insert_delay() command will add to the
above minimum delays, giving for instance the
ability to skew the BFM starting time.</p>
</td>
</tr>
<tr class="row-odd"><td><p>cmd_queue_count_max</p></td>
<td><p>natural</p></td>
<td><p>C_CMD_QUEUE_COUNT_MAX</p></td>
<td><p>Maximum pending number in command queue before
queue is full. Adding additional commands will
result in an ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>cmd_queue_count_threshold</p></td>
<td><p>natural</p></td>
<td><p>C_CMD_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>An alert will be issued if command queue exceeds
this count. Used for early warning if command
queue is almost full. Will be ignored if set to
0.</p></td>
</tr>
<tr class="row-odd"><td><p>cmd_queue_count_threshold_severity</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>C_CMD_QUEUE_COUNT_THRESHOLD_SEERITY</p></td>
<td><p>Severity of alert to be initiated if exceeding
cmd_queue_count_threshold</p></td>
</tr>
<tr class="row-even"><td><p>result_queue_count_max</p></td>
<td><p>natural</p></td>
<td><p>C_RESULT_QUEUE_COUNT_MAX</p></td>
<td><p>Maximum number of unfetched results before
result_queue is full</p></td>
</tr>
<tr class="row-odd"><td><p>result_queue_count_threshold</p></td>
<td><p>natural</p></td>
<td><p>C_RESULT_QUEUE_COUNT_THRESHOLD</p></td>
<td><p>An alert will be issued if result queue exceeds
this count. Used for early warning if result
queue is almost full. Will be ignored if set to
0.</p></td>
</tr>
<tr class="row-even"><td><p>result_queue_count_threshold_severity</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>C_RESULT_QUEUE_COUNT_THRESHOLD_SEVERITY</p></td>
<td><p>Severity of alert to be initiated if exceeding
result_queue_count_threshold</p></td>
</tr>
<tr class="row-odd"><td><p>bfm_config</p></td>
<td><p><a class="reference internal" href="#t-spi-bfm-config"><span class="std std-ref">t_spi_bfm_config</span></a></p></td>
<td><p>C_SPI_BFM_CONFIG_DEFAULT</p></td>
<td><p>Configuration for the SPI BFM</p></td>
</tr>
<tr class="row-even"><td><p>msg_id_panel</p></td>
<td><p>t_msg_id_panel</p></td>
<td><p>C_VVC_MSG_ID_PANEL_DEFAULT</p></td>
<td><p>VVC dedicated message ID panel. See
<a class="reference internal" href="vvc_framework.html#vvc-framework-verbosity-ctrl"><span class="std std-ref">Scope of Verbosity Control</span></a> for how to
use verbosity control.</p></td>
</tr>
<tr class="row-odd"><td><p>unwanted_activity_severity</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>C_UNWANTED_ACTIVITY_SEVERITY</p></td>
<td><p>Severity of alert to be issued if unwanted
activity on the DUT outputs is detected. It is
enabled with ERROR severity by default.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cmd/result queue parameters in the configuration record are unused and will be removed in v3.0, use instead the entity generic constants.</p>
</div>
<p>The configuration record can be accessed from the Central Testbench Sequencer through the shared variable array, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">shared_spi_vvc_config</span><span class="p">(</span><span class="n">C_VVC_IDX_MASTER</span><span class="p">).</span><span class="n">inter_bfm_delay</span><span class="p">.</span><span class="n">delay_in_time</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">ms</span><span class="p">;</span>
<span class="n">shared_spi_vvc_config</span><span class="p">(</span><span class="n">C_VVC_IDX_SLAVE</span><span class="p">).</span><span class="n">bfm_config</span><span class="p">.</span><span class="n">CPOL</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="status-record">
<h3>Status Record<a class="headerlink" href="#status-record" title="Link to this heading"></a></h3>
<p><strong>vvc_status</strong> accessible via <strong>shared_spi_vvc_status</strong></p>
<p>The current status of the VVC can be retrieved during simulation. This is achieved by reading from the shared variable from the
test sequencer. The record contents can be seen below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Record element</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>current_cmd_idx</p></td>
<td><p>natural</p></td>
<td><p>Command index currently running</p></td>
</tr>
<tr class="row-odd"><td><p>previous_cmd_idx</p></td>
<td><p>natural</p></td>
<td><p>Previous command index to run</p></td>
</tr>
<tr class="row-even"><td><p>pending_cmd_idx</p></td>
<td><p>natural</p></td>
<td><p>Pending number of commands in the command queue</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id2">
<h3>Methods<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>All VVC procedures are defined in vvc_methods_pkg.vhd (dedicated to this VVC).</p></li>
<li><p>See <a class="reference internal" href="vvc_framework.html#vvc-framework-methods"><span class="std std-ref">Common VVC Methods</span></a> for procedures which are common to all VVCs.</p></li>
<li><p>It is also possible to send a multicast to all instances of a VVC with ALL_INSTANCES as parameter for vvc_instance_idx.</p></li>
<li><p>All parameters in brackets are optional.</p></li>
</ul>
<section id="spi-master-transmit-and-receive-vvc">
<span id="id3"></span><h4>spi_master_transmit_and_receive()<a class="headerlink" href="#spi-master-transmit-and-receive-vvc" title="Link to this heading"></a></h4>
<p>Adds a master transmit and receive command to the SPI VVC executor queue, which will run as soon as all preceding commands have
completed. When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-master-transmit-and-receive-bfm"><span class="std std-ref">spi_master_transmit_and_receive()</span></a> procedure.</p>
<p>The received data will not be returned in this procedure call since it is non-blocking for the sequencer/caller, but the received
data will be stored in the VVC for a potential future fetch (see example with fetch_result below).
If the data_routing is set to TO_SB, the received data will be sent to the SPI VVC dedicated scoreboard where it will be
checked against the expected value (provided by the testbench). This procedure can only be called when the SPI VVC is instantiated
in master mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘true’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="n">data_routing</span><span class="p">,]</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="n">data_routing</span><span class="p">,]</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_routing</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-data-routing"><span class="std std-ref">t_data_routing</span></a></p></td>
<td><p>Selects the destination of the received data</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;AF&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SPI Master Tx and Rx to/from Peripheral 1. Rx data will be stored in VVC to be retrieved later using fetch_result.&quot;</span><span class="p">);</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;AF&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TO_SB</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SPI Master Tx and Rx to/from Peripheral 1. Rx data will be sent to the SPI scoreboard for checking.&quot;</span><span class="p">);</span>

<span class="c1">-- Example with fetch_result() call: Result is placed in v_result</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">natural</span><span class="p">;</span><span class="w">                       </span><span class="c1">-- Command index for the last receive</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_result</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="nn">work</span><span class="p">.</span><span class="n">vvc_cmd_pkg</span><span class="p">.</span><span class="n">t_vvc_result</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Result from read.</span>
<span class="p">...</span>
<span class="n">spi_master_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;AB&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;CD&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting two bytes to Peripheral 1 and receiving from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">us</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wait for transmit and receive to finish&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching first byte from transmit and receive operation&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching second byte from transmit and receive operation&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p><a class="reference internal" href="vvc_framework.html#t-vvc-result"><span class="std std-ref">t_vvc_result</span></a> is defined in the corresponding vvc_cmd_pkg.vhd for the VIP.</p>
</div>
</section>
<section id="spi-master-transmit-only">
<span id="spi-master-transmit-only-vvc"></span><h4>spi_master_transmit_only()<a class="headerlink" href="#spi-master-transmit-only" title="Link to this heading"></a></h4>
<p>Adds a master transmit command to the SPI VVC executor queue, which will run as soon as all preceding commands have completed.
When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-master-transmit-bfm"><span class="std std-ref">spi_master_transmit()</span></a> procedure.</p>
<p>This procedure will ignore the received data from the slave DUT. This procedure can only be called when the SPI VVC is
instantiated in master mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘true’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">spi_master_transmit_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">spi_master_transmit_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1&quot;</span><span class="p">,</span>
<span class="w">                         </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-receive-only">
<span id="spi-master-receive-only-vvc"></span><h4>spi_master_receive_only()<a class="headerlink" href="#spi-master-receive-only" title="Link to this heading"></a></h4>
<p>Adds a master receive command to the SPI VVC executor queue, which will run as soon as all preceding commands have completed. When
the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-master-receive-bfm"><span class="std std-ref">spi_master_receive()</span></a> procedure.</p>
<p>The procedure will transmit dummy data (0x0) to the DUT.
The received data will not be returned in this procedure call since it is non-blocking for the sequencer/caller, but the received
data will be stored in the VVC for a potential future fetch (see example with fetch_result below). When receiving multiple words,
each word must be fetched separately with the same command index.
If the data_routing is set to TO_SB, the received data will be sent to the SPI VVC dedicated scoreboard where it will be
checked against the expected value (provided by the testbench). This procedure can only be called when the SPI VVC is instantiated
in master mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘true’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_receive_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">data_routing</span><span class="p">,]</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">num_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_routing</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-data-routing"><span class="std std-ref">t_data_routing</span></a></p></td>
<td><p>Selects the destination of the received data</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>num_words</p></td>
<td><p>in</p></td>
<td><p>positive</p></td>
<td><p>Number of words that shall be received. Default value is
1.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving from Peripheral 1. Rx data will be stored in VVC to be retrieved later using fetch_result.&quot;</span><span class="p">);</span>
<span class="n">spi_master_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">TO_SB</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving 6 words from Peripheral 1. Rx data will be sent to the SPI scoreboard for checking.&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>

<span class="c1">-- Example with fetch_result() call: Result is placed in v_result</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">natural</span><span class="p">;</span><span class="w">                       </span><span class="c1">-- Command index for the last receive</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_result</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="nn">work</span><span class="p">.</span><span class="n">vvc_cmd_pkg</span><span class="p">.</span><span class="n">t_vvc_result</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Result from read.</span>
<span class="p">...</span>
<span class="n">spi_master_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">us</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wait for receive to finish&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching result from receive operation&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p><a class="reference internal" href="vvc_framework.html#t-vvc-result"><span class="std std-ref">t_vvc_result</span></a> is defined in the corresponding vvc_cmd_pkg.vhd for the VIP.</p>
</div>
</section>
<section id="spi-master-transmit-and-check-vvc">
<span id="id4"></span><h4>spi_master_transmit_and_check()<a class="headerlink" href="#spi-master-transmit-and-check-vvc" title="Link to this heading"></a></h4>
<p>Adds a master transmit and check command to the SPI VVC executor queue, which will run as soon as all preceding commands have
completed. When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-master-transmit-and-check-bfm"><span class="std std-ref">spi_master_transmit_and_check()</span></a> procedure.</p>
<p>This procedure can only be called when the SPI VVC is instantiated in master mode, i.e. setting the VVC entity generic constant
‘GC_MASTER_MODE’ to ‘true’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;5F&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and expecting data back&quot;</span><span class="p">);</span>
<span class="n">spi_master_transmit_and_check</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">C_CR_BYTES</span><span class="p">,</span><span class="w"> </span><span class="n">C_EXP_BYTES</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and expecting data back&quot;</span><span class="p">,</span>
<span class="w">                              </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span><span class="w"> </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-master-check-only">
<span id="spi-master-check-only-vvc"></span><h4>spi_master_check_only()<a class="headerlink" href="#spi-master-check-only" title="Link to this heading"></a></h4>
<p>Adds a master check command to the SPI VVC executor queue, which will run as soon as all preceding commands have completed. When
the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-master-check-bfm"><span class="std std-ref">spi_master_check()</span></a> procedure.</p>
<p>The procedure will transmit dummy data (0x0) to the DUT. This procedure can only be called when the SPI VVC is instantiated in
master mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘true’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_master_check_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
<span class="n">spi_master_check_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data_exp</span><span class="p">(</span><span class="n">slv_array</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_when_transfer_is_done</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">action_between_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>action_when_transfer_is_done</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n after the operation is finished. Default
value is RELEASE_LINE_AFTER_TRANSFER.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>action_between_words</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>Whether or not the SPI master method shall release or
hold ss_n between words when transmitting a word array.
Default value is HOLD_LINE_BETWEEN_WORDS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_master_check_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting carriage return from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">spi_master_check_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">C_CR_BYTE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting carriage return from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">RELEASE_LINE_AFTER_TRANSFER</span><span class="p">,</span>
<span class="w">                      </span><span class="n">HOLD_LINE_BETWEEN_WORDS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-transmit-and-receive-vvc">
<span id="id5"></span><h4>spi_slave_transmit_and_receive()<a class="headerlink" href="#spi-slave-transmit-and-receive-vvc" title="Link to this heading"></a></h4>
<p>Adds a slave transmit and receive command to the SPI VVC executor queue, which will run as soon as all preceding commands have
completed. When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-slave-transmit-and-receive-bfm"><span class="std std-ref">spi_slave_transmit_and_receive()</span></a> procedure.</p>
<p>The received data will not be returned in this procedure call since it is non-blocking for the sequencer/caller, but the received
data will be stored in the VVC for a potential future fetch (see example with fetch_result below).
If the data_routing is set to TO_SB, the received data will be sent to the SPI VVC dedicated scoreboard where it will be
checked against the expected value (provided by the testbench). This procedure can only be called when the SPI VVC is instantiated
in slave mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘false’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">data_routing</span><span class="p">,]</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_routing</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-data-routing"><span class="std std-ref">t_data_routing</span></a></p></td>
<td><p>Selects the destination of the received data</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and receiving data back&quot;</span><span class="p">);</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TO_SB</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and receiving data back&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Example with fetch_result() call: Result is placed in v_result</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">natural</span><span class="p">;</span><span class="w">                       </span><span class="c1">-- Command index for the last receive</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_result</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="nn">work</span><span class="p">.</span><span class="n">vvc_cmd_pkg</span><span class="p">.</span><span class="n">t_vvc_result</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Result from read.</span>
<span class="p">...</span>
<span class="n">spi_slave_transmit_and_receive</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;AB&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;CD&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting two bytes to Peripheral 1 and receiving from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">us</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wait for transmit and receive to finish&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching first byte from transmit and receive operation&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching second byte from transmit and receive operation&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p><a class="reference internal" href="vvc_framework.html#t-vvc-result"><span class="std std-ref">t_vvc_result</span></a> is defined in the corresponding vvc_cmd_pkg.vhd for the VIP.</p>
</div>
</section>
<section id="spi-slave-transmit-only">
<span id="spi-slave-transmit-only-vvc"></span><h4>spi_slave_transmit_only()<a class="headerlink" href="#spi-slave-transmit-only" title="Link to this heading"></a></h4>
<p>Adds a slave transmit command to the SPI VVC executor queue, which will run as soon as all preceding commands have
completed. When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-slave-transmit-bfm"><span class="std std-ref">spi_slave_transmit()</span></a> procedure.</p>
<p>This procedure will ignore the received data from the master DUT. This procedure can only be called when the SPI VVC is
instantiated in slave mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘false’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">spi_slave_transmit_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-receive-only">
<span id="spi-slave-receive-only-vvc"></span><h4>spi_slave_receive_only()<a class="headerlink" href="#spi-slave-receive-only" title="Link to this heading"></a></h4>
<p>Adds a slave receive command to the SPI VVC executor queue, which will run as soon as all preceding commands have completed. When
the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-slave-receive-bfm"><span class="std std-ref">spi_slave_receive()</span></a> procedure.</p>
<p>The procedure will transmit dummy data (0x0) to the DUT.
The received data will not be returned in this procedure call since it is non-blocking for the sequencer/caller, but the received
data will be stored in the VVC for a potential future fetch (see example with fetch_result below). When receiving multiple words,
each word must be fetched separately with the same command index.
If the data_routing is set to TO_SB, the received data will be sent to the SPI VVC dedicated scoreboard where it will be
checked against the expected value (provided by the testbench). This procedure can only be called when the SPI VVC is instantiated
in slave mode, i.e. setting the VVC entity generic constant ‘GC_MASTER_MODE’ to ‘false’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_receive_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">data_routing</span><span class="p">,]</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">num_words</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_routing</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-data-routing"><span class="std std-ref">t_data_routing</span></a></p></td>
<td><p>Selects the destination of the received data</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>num_words</p></td>
<td><p>in</p></td>
<td><p>positive</p></td>
<td><p>Number of words that shall be received. Default value is
1.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">spi_slave_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">TO_SB</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_ON_NEXT_SS</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Example with fetch_result() call: Result is placed in v_result</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">natural</span><span class="p">;</span><span class="w">                       </span><span class="c1">-- Command index for the last receive</span>
<span class="k">variable</span><span class="w"> </span><span class="n">v_result</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="nn">work</span><span class="p">.</span><span class="n">vvc_cmd_pkg</span><span class="p">.</span><span class="n">t_vvc_result</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Result from read.</span>
<span class="p">...</span>
<span class="n">spi_slave_receive_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Receiving from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">v_cmd_idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">us</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Wait for receive to finish&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">v_cmd_idx</span><span class="p">,</span><span class="w"> </span><span class="n">v_result</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Fetching result from receive operation&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p><a class="reference internal" href="vvc_framework.html#t-vvc-result"><span class="std std-ref">t_vvc_result</span></a> is defined in the corresponding vvc_cmd_pkg.vhd for the VIP.</p>
</div>
</section>
<section id="spi-slave-transmit-and-check-vvc">
<span id="id6"></span><h4>spi_slave_transmit_and_check()<a class="headerlink" href="#spi-slave-transmit-and-check-vvc" title="Link to this heading"></a></h4>
<p>Adds a slave transmit and check command to the SPI VVC executor queue, which will run as soon as all preceding commands have
completed. When the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-slave-transmit-and-check-bfm"><span class="std std-ref">spi_slave_transmit_and_check()</span></a> procedure.</p>
<p>This procedure can only be called when the SPI VVC is instantiated in slave mode, i.e. setting the VVC entity generic constant
‘GC_MASTER_MODE’ to ‘false’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">data_exp</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to be transmitted to the DUT, either a
single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;5F&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and expecting data back&quot;</span><span class="p">);</span>
<span class="n">spi_slave_transmit_and_check</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;AA&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;BB&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;3A&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Transmitting carriage return to Peripheral 1 and expecting data back&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_IMMEDIATE</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="spi-slave-check-only">
<span id="spi-slave-check-only-vvc"></span><h4>spi_slave_check_only()<a class="headerlink" href="#spi-slave-check-only" title="Link to this heading"></a></h4>
<p>Adds a slave check command to the SPI VVC executor queue, which will run as soon as all preceding commands have completed. When
the command is scheduled to run, the executor calls the BFM <a class="reference internal" href="#spi-slave-check-bfm"><span class="std std-ref">spi_slave_check()</span></a> procedure.</p>
<p>The procedure will transmit dummy data (0x0) to the DUT.
This procedure can only be called when the SPI VVC is instantiated in slave mode, i.e. setting the VVC entity generic constant
‘GC_MASTER_MODE’ to ‘false’.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">spi_slave_check_only</span><span class="p">(</span><span class="n">VVCT</span><span class="p">,</span><span class="w"> </span><span class="n">vvc_instance_idx</span><span class="p">,</span><span class="w"> </span><span class="n">data_exp</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">alert_level</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">when_to_start_transfer</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>VVCT</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>data_exp</p></td>
<td><p>in</p></td>
<td><p>std_logic_vector</p>
<p>t_slv_array</p>
</td>
<td><p>The data value to expect when receiving data from the
DUT, either a single word or a word array.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended in the log/alert</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>Sets the severity for the alert. Default value is ERROR.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>when_to_start_transfer</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>Determines if SPI slave shall wait for next ss_n if a
transfer has already started. Default value is
START_TRANSFER_ON_NEXT_SS.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">spi_slave_check_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;0D&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expecting carriage return from Peripheral 1&quot;</span><span class="p">);</span>
<span class="n">spi_slave_check_only</span><span class="p">(</span><span class="n">SPI_VVCT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">x&quot;3A&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">x&quot;3B&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Expecting carriage return from Peripheral 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">START_TRANSFER_IMMEDIATE</span><span class="p">,</span><span class="w"> </span><span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="activity-watchdog">
<h3>Activity Watchdog<a class="headerlink" href="#activity-watchdog" title="Link to this heading"></a></h3>
<p>The VVCs support a centralized VVC activity register which the activity watchdog uses to monitor the VVC activities. The VVCs will
register their presence to the VVC activity register at start-up, and report when ACTIVE and INACTIVE, using dedicated VVC
activity register methods, and trigger the global_trigger_vvc_activity_register signal during simulations. The activity watchdog
is continuously monitoring the VVC activity register for VVC inactivity and raises an alert if no VVC activity is registered
within the specified timeout period.</p>
<p>Include <code class="docutils literal notranslate"><span class="pre">activity_watchdog(num_exp_vvc,</span> <span class="pre">timeout,</span> <span class="pre">[alert_level,</span> <span class="pre">[msg]])</span></code> in the testbench to start using the activity watchdog.
Note that setting the exact number of expected VVCs in the VVC activity register can be omitted by setting num_exp_vvc = 0.</p>
<p>More information can be found in <a class="reference internal" href="vvc_framework.html#vvc-framework-activity-watchdog"><span class="std std-ref">Essential Mechanisms - Activity Watchdog</span></a>.</p>
</section>
<section id="transaction-info">
<h3>Transaction Info<a class="headerlink" href="#transaction-info" title="Link to this heading"></a></h3>
<p>This VVC supports transaction info, a UVVM concept for distributing transaction information in a controlled manner within the
complete testbench environment. The transaction info may be used in many different ways, but the main purpose is to share
information directly from the VVC to a DUT model.</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">SPI transaction info record fields. Transaction Type: t_base_transaction (BT) - accessible via <strong>shared_spi_vvc_transaction_info.bt</strong></span><a class="headerlink" href="#id10" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Info field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>operation</p></td>
<td><p>t_operation</p></td>
<td><p>NO_OPERATION</p></td>
<td><p>Current VVC operation, e.g. INSERT_DELAY,
POLL_UNTIL, READ, WRITE</p></td>
</tr>
<tr class="row-odd"><td><p>data</p></td>
<td><p>t_slv_array(31 downto 0)(31
downto 0)</p></td>
<td><p>0x0</p></td>
<td><p>The data to be transmitted</p></td>
</tr>
<tr class="row-even"><td><p>data_exp</p></td>
<td><p>t_slv_array(31 downto 0)(31
downto 0)</p></td>
<td><p>0x0</p></td>
<td><p>The expected data to be received</p></td>
</tr>
<tr class="row-odd"><td><p>num_words</p></td>
<td><p>natural</p></td>
<td><p>0</p></td>
<td><p>Number of words that shall be received</p></td>
</tr>
<tr class="row-even"><td><p>word_length</p></td>
<td><p>natural</p></td>
<td><p>0</p></td>
<td><p>Length of words to be sent or received</p></td>
</tr>
<tr class="row-odd"><td><p>when_to_start_transfer</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-when-to-start-transfer"><span class="std std-ref">t_when_to_start_transfer</span></a></p></td>
<td><p>START_TRANSFER_IMMEDIATE</p></td>
<td><p>Determines if SPI slave shall wait for next ss_n
if a transfer has already started</p></td>
</tr>
<tr class="row-even"><td><p>action_when_transfer_is_done</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-when-transfer-is-done"><span class="std std-ref">t_action_when_transfer_is_done</span></a></p></td>
<td><p>RELEASE_LINE_AFTER_TRANSFER</p></td>
<td><p>Determines if SPI master shall release or hold
ss_n after the transfer is done</p></td>
</tr>
<tr class="row-odd"><td><p>action_between_words</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-action-between-words"><span class="std std-ref">t_action_between_words</span></a></p></td>
<td><p>HOLD_LINE_BETWEEN_WORDS</p></td>
<td><p>Determines if SPI master shall release or hold
ss_n between words when transmitting a word
array</p></td>
</tr>
<tr class="row-even"><td><p>vvc_meta</p></td>
<td><p>t_vvc_meta</p></td>
<td><p>C_VVC_META_DEFAULT</p></td>
<td><p>VVC meta data of the executing VVC command</p></td>
</tr>
<tr class="row-odd"><td><p>-&gt; msg</p></td>
<td><p>string</p></td>
<td><p>“”</p></td>
<td><p>Message of executing VVC command</p></td>
</tr>
<tr class="row-even"><td><p>-&gt; cmd_idx</p></td>
<td><p>integer</p></td>
<td><p>-1</p></td>
<td><p>Command index of executing VVC command</p></td>
</tr>
<tr class="row-odd"><td><p>transaction_status</p></td>
<td><p>t_transaction_status</p></td>
<td><p>INACTIVE</p></td>
<td><p>Set to INACTIVE, IN_PROGRESS, FAILED or
SUCCEEDED during a transaction</p></td>
</tr>
</tbody>
</table>
<p>More information can be found in <a class="reference internal" href="vvc_framework.html#vvc-framework-transaction-info"><span class="std std-ref">Essential Mechanisms - Distribution of Transaction Info</span></a>.</p>
</section>
<section id="scoreboard">
<h3>Scoreboard<a class="headerlink" href="#scoreboard" title="Link to this heading"></a></h3>
<p>This VVC has built in Scoreboard functionality where data can be routed by setting the TO_SB parameter in supported method calls,
i.e. spi_master_receive_only(). Note that the data is only stored in the scoreboard and not accessible with the fetch_result() method
when the TO_SB parameter is applied. The SPI scoreboard is accessible from the testbench as a shared variable SPI_VVC_SB, located
in the vvc_methods_pkg.vhd, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">SPI_VVC_SB</span><span class="p">.</span><span class="n">add_expected</span><span class="p">(</span><span class="n">C_SPI_VVC_IDX</span><span class="p">,</span><span class="w"> </span><span class="n">pad_spi_sb</span><span class="p">(</span><span class="n">v_expected</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Adding expected&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The SPI scoreboard is per default a 32 bits wide standard logic vector. When sending expected data to the scoreboard, where the
data width is smaller than the default scoreboard width, we recommend zero-padding the data with the pad_spi_sb() function, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">SPI_VVC_SB</span><span class="p">.</span><span class="n">add_expected</span><span class="p">(</span><span class="o">&lt;</span><span class="n">SPI</span><span class="w"> </span><span class="n">VVC</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">number</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">pad_spi_sb</span><span class="p">(</span><span class="o">&lt;</span><span class="n">exp</span><span class="w"> </span><span class="n">data</span><span class="o">&gt;</span><span class="p">));</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="vip_scoreboard.html#vip-scoreboard"><span class="std std-ref">Bitvis VIP Scoreboard</span></a> for a complete list of available commands and additional information. All of the listed Generic
Scoreboard commands are available for the SPI VVC scoreboard using the SPI_VVC_SB.</p>
</section>
<section id="unwanted-activity-detection">
<h3>Unwanted Activity Detection<a class="headerlink" href="#unwanted-activity-detection" title="Link to this heading"></a></h3>
<p>This VVC supports detection of unwanted activity from the DUT. This mechanism will give an alert if the DUT generates any unexpected
bus activity. It assures that no data is output from the DUT when it is not expected, i.e. read/receive/check/expect VVC methods are
not called. Once the VVC is inactive, it starts to monitor continuously on the DUT outputs. When unwanted activity is detected, the
VVC issues an alert.</p>
<p>The unwanted activity detection can be configured from the central testbench sequencer, where the severity of alert can be changed
to a different value. To disable this feature in the testbench, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">shared_spi_vvc_config</span><span class="p">(</span><span class="n">C_VVC_INDEX</span><span class="p">).</span><span class="n">unwanted_activity_severity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">NO_ALERT</span><span class="p">;</span>
</pre></div>
</div>
<p>For SPI VVC, the unwanted activity detection is enabled by default with severity ERROR.</p>
<p>More information can be found in <a class="reference internal" href="vvc_framework.html#vvc-framework-unwanted-activity"><span class="std std-ref">Essential Mechanisms - Unwanted Activity Detection</span></a>.</p>
</section>
<section id="id7">
<h3>Compilation<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>The SPI VVC must be compiled with VHDL-2008 or newer. It is dependent on the following libraries:</p>
<blockquote>
<div><ul class="simple">
<li><p>UVVM Utility Library (UVVM-Util)</p></li>
<li><p>UVVM VVC Framework</p></li>
<li><p>Bitvis VIP Scoreboard</p></li>
<li><p>SPI BFM</p></li>
</ul>
</div></blockquote>
<p>Before compiling the SPI VVC, assure that uvvm_util, uvvm_vvc_framework and bitvis_vip_scoreboard have been compiled.</p>
<p>See <a class="reference internal" href="vvc_framework.html#vvc-framework-compile-scripts"><span class="std std-ref">Essential Mechanisms - Compile Scripts</span></a> for information about compile scripts.</p>
<table class="docutils align-default" id="id11">
<caption><span class="caption-text">Compile order for the SPI VVC</span><a class="headerlink" href="#id11" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Compile to library</p></th>
<th class="head"><p>File</p></th>
<th class="head"><p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>spi_bfm_pkg.vhd</p></td>
<td><p>SPI BFM</p></td>
</tr>
<tr class="row-odd"><td><p>bitvis_vip_spi</p></td>
<td><p>transaction_pkg.vhd</p></td>
<td><p>SPI transaction package with DTT types,
constants, etc.</p></td>
</tr>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>vvc_cmd_pkg.vhd</p></td>
<td><p>SPI VVC command types and operations</p></td>
</tr>
<tr class="row-odd"><td><p>bitvis_vip_spi</p></td>
<td><p>../uvvm_vvc_framework/src_target_dependent/td_target_support_pkg.vhd</p></td>
<td><p>UVVM VVC target support package, compiled into
this VVC library</p></td>
</tr>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>../uvvm_vvc_framework/src_target_dependent/td_vvc_framework_common_methods_pkg.vhd</p></td>
<td><p>Common UVVM framework methods compiled into the
this VVC library</p></td>
</tr>
<tr class="row-odd"><td><p>bitvis_vip_spi</p></td>
<td><p>vvc_sb_pkg.vhd</p></td>
<td><p>SPI VVC scoreboard</p></td>
</tr>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>vvc_methods_pkg.vhd</p></td>
<td><p>SPI VVC methods</p></td>
</tr>
<tr class="row-odd"><td><p>bitvis_vip_spi</p></td>
<td><p>../uvvm_vvc_framework/src_target_dependent/td_queue_pkg.vhd</p></td>
<td><p>UVVM queue package for this VVC</p></td>
</tr>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>../uvvm_vvc_framework/src_target_dependent/td_vvc_entity_support_pkg.vhd</p></td>
<td><p>UVVM VVC entity support compiled into this
VVC library</p></td>
</tr>
<tr class="row-odd"><td><p>bitvis_vip_spi</p></td>
<td><p>spi_vvc.vhd</p></td>
<td><p>SPI VVC</p></td>
</tr>
<tr class="row-even"><td><p>bitvis_vip_spi</p></td>
<td><p>vvc_context.vhd</p></td>
<td><p>SPI VVC context file</p></td>
</tr>
</tbody>
</table>
<section id="id8">
<h4>Simulator compatibility and setup<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>See <a class="reference internal" href="uvvm_intro.html#uvvm-prerequisites"><span class="std std-ref">Prerequisites</span></a> for a list of supported simulators.</p></li>
<li><p>For required simulator setup see <a class="reference internal" href="utility_library.html#util-simulator-compatibility"><span class="std std-ref">UVVM-Util Simulator compatibility and setup</span></a>.</p></li>
</ul>
</section>
</section>
<section id="id9">
<h3>Additional Documentation<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p>For additional documentation on the SPI protocol, please see the SPI specification, e.g. “ST TN0897 Technical note ST SPI protocol.
ID 023176 Rev 2”.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul class="simple">
<li><p>This is a simplified Verification IP (VIP) for SPI.</p></li>
<li><p>The given VIP complies with the basic SPI protocol and thus allows a normal access towards a SPI interface.</p></li>
<li><p>This VIP is not a SPI protocol checker.</p></li>
<li><p>For a more advanced VIP please contact UVVM support at <a class="reference external" href="mailto:info&#37;&#52;&#48;uvvm&#46;org">info<span>&#64;</span>uvvm<span>&#46;</span>org</a></p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Disclaimer: This IP and any part thereof are provided “as is”, without warranty of any kind, express or implied, including but
not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or
otherwise, arising from, out of or in connection with this IP.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vip_spec_cov.html" class="btn btn-neutral float-left" title="Bitvis VIP Specification Coverage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vip_uart.html" class="btn btn-neutral float-right" title="Bitvis VIP UART" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025 by UVVM steering group. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
         .wy-nav-content { max-width: none; }
  </style>



</body>
</html>