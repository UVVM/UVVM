

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>VVC Framework &mdash; UVVM  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Protected types" href="protected_types.html" />
    <link rel="prev" title="Optimized Randomization" href="optimized_rand.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #F5F5F5" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/uvvm.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="uvvm_intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uvvm_getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="utility_library.html">Utility Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="rand_pkg_overview.html">Enhanced Randomization</a></li>
<li class="toctree-l1"><a class="reference internal" href="func_cov_pkg_overview.html">Functional Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimized_rand.html">Optimized Randomization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">VVC Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#common-vvc-methods">Common VVC Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#await-completion">await_completion()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#await-any-completion">await_any_completion()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enable-log-msg">enable_log_msg()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disable-log-msg">disable_log_msg()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flush-command-queue">flush_command_queue()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fetch-result">fetch_result()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#insert-delay">insert_delay()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminate-current-command">terminate_current_command()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminate-all-commands">terminate_all_commands()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-last-received-cmd-idx">get_last_received_cmd_idx()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#broadcasting-and-multicasting">Broadcasting and Multicasting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vvc-broadcast">VVC_BROADCAST</a></li>
<li class="toctree-l4"><a class="reference internal" href="#all-instances">ALL_INSTANCES</a></li>
<li class="toctree-l4"><a class="reference internal" href="#all-channels">ALL_CHANNELS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-vvct-all-instances">C_VVCT_ALL_INSTANCES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#essential-mechanisms">Essential Mechanisms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libraries">Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uvvm-initialization">UVVM Initialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ti-uvvm-engine">ti_uvvm_engine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#await-uvvm-initialization">await_uvvm_initialization()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uvvm-and-vvc-user-accessible-shared-variables-and-global-signals">UVVM and VVC User Accessible Shared Variables and Global Signals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shared-uvvm-status">shared_uvvm_status</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-vvc-name-vvc-config">shared_&lt;vvc_name&gt;_vvc_config</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-vvc-name-vvc-status">shared_&lt;vvc_name&gt;_vvc_status</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-vvc-name-vvc-transaction-trigger">global_&lt;vvc_name&gt;_vvc_transaction_trigger</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-vvc-name-vvc-transaction-info">shared_&lt;vvc_name&gt;_vvc_transaction_info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-status-configuration-and-transaction-information">VVC Status, Configuration and Transaction Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#activity-watchdog">Activity Watchdog</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-of-transaction-info-from-vvcs-and-or-monitors">Distribution of Transaction Info - From VVCs and/or Monitors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-definitions">Transaction definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-information">Transaction information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-info-transfer">Transaction Info transfer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-info-record-signals">Transaction Info record signals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-info-signal-and-shared-variable">Transaction Info signal and shared variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-of-transaction-info-usage">Examples of Transaction Info Usage</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#mechanism">Mechanism</a></li>
<li class="toctree-l5"><a class="reference internal" href="#complex-protocols">Complex Protocols</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-local-sequencers">VVC Local Sequencers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#local-sequencer-requirements">Local sequencer requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-aware-error-injection">Protocol Aware Error Injection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#uvvm-error-injection-principles">UVVM error injection principles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-injection-in-bfms">Error injection in BFMs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-injection-in-vvcs">Error injection in VVCs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#naming-and-type-usage">Naming and type usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#built-in-randomization">Built-in randomization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#uvvm-vip-randomization-principles">UVVM VIP randomization principles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-randomization-in-bfms">Data randomization in BFMs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-randomization-in-vvcs">Data randomization in VVCs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vvc-command-syntax">VVC Command Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testbench-data-routing">Testbench Data Routing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#to-from-buffer">To/from Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#to-scoreboard">To Scoreboard</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-routing-options">Data routing options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">VVC Command Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-property-checkers">Controlling Property Checkers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#property-check-configuration">Property check configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-up-the-configuration">Setting up the configuration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-parameters-and-sequence-for-randomization-sources-and-destinations">VVC Parameters and Sequence for Randomization, Sources and Destinations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-central-sequencers">Multiple Central Sequencers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monitors">Monitors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#transfer-of-monitor-information-to-the-testbench">Transfer of Monitor information to the testbench</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transaction-info-transfer-signals">Transaction info transfer signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#compile-scripts">Compile Scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope-of-verbosity-control">Scope of Verbosity Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hierarchical-vvcs">Hierarchical VVCs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hvvc-usage">HVVC usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vvc-implementation-guide">VVC Implementation Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementing-your-new-vvc">Implementing your new VVC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependent-and-independent-source">Dependent and independent source</a></li>
<li class="toctree-l3"><a class="reference internal" href="#name-vvc-vhd">&lt;name&gt;_vvc.vhd</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#for-single-channel-vvcs">For single channel VVCs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#entity">Entity</a></li>
<li class="toctree-l5"><a class="reference internal" href="#declarations">Declarations</a></li>
<li class="toctree-l5"><a class="reference internal" href="#constructor">Constructor</a></li>
<li class="toctree-l5"><a class="reference internal" href="#command-interpreter">Command Interpreter</a></li>
<li class="toctree-l5"><a class="reference internal" href="#command-executor">Command Executor</a></li>
<li class="toctree-l5"><a class="reference internal" href="#command-terminator">Command Terminator</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#additional-for-multi-channel-vvcs">Additional for multi-channel VVCs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-cmd-pkg-vhd">vvc_cmd_pkg.vhd</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#t-operation">t_operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#t-vvc-cmd-record">t_vvc_cmd_record</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constants">Constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-variables">Shared Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-methods-pkg-vhd">vvc_methods_pkg.vhd</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constants-and-aliases">Constants and aliases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#name-vvct">&lt;NAME&gt;_VVCT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#t-vvc-config">t_vvc_config</a></li>
<li class="toctree-l4"><a class="reference internal" href="#t-vvc-status">t_vvc_status</a></li>
<li class="toctree-l4"><a class="reference internal" href="#t-transaction-info-for-waveview">t_transaction_info_for_waveview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vvc-dedicated-methods">VVC Dedicated Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vvc-context-vhd">vvc_context.vhd</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bfm-prerequisites">BFM prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uvvm-framework-packages">UVVM Framework Packages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#td-target-support-pkg-vhd">td_target_support_pkg.vhd</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#target-record">Target record</a></li>
<li class="toctree-l5"><a class="reference internal" href="#string-methods">String methods</a></li>
<li class="toctree-l5"><a class="reference internal" href="#send-command-to-vvc">send_command_to_vvc</a></li>
<li class="toctree-l5"><a class="reference internal" href="#setting-the-command-field">Setting the command field</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#td-vvc-entity-support-pkg-vhd">td_vvc_entity_support_pkg.vhd</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="protected_types.html">Protected types</a></li>
<li class="toctree-l1"><a class="reference internal" href="fifo_collection.html">UVVM FIFO Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_queue.html">UVVM Generic Queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_avalon_mm.html">Bitvis VIP Avalon MM</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_avalon_st.html">Bitvis VIP Avalon-ST</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axi.html">Bitvis VIP AXI</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axilite.html">Bitvis VIP Axi-Lite</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_axistream.html">Bitvis VIP Axi-Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_clock_generator.html">Bitvis VIP Clock Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_error_injection.html">Bitvis VIP Error Injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_ethernet.html">Bitvis VIP Ethernet</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_gmii.html">Bitvis VIP GMII</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_gpio.html">Bitvis VIP GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_hvvc_to_vvc_bridge.html">Bitvis VIP HVVC-to-VVC Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_i2c.html">Bitvis VIP I2C</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_rgmii.html">Bitvis VIP RGMII</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_sbi.html">Bitvis VIP SBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_scoreboard.html">Bitvis VIP Scoreboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_spec_cov.html">Bitvis VIP Specification Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_spi.html">Bitvis VIP SPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_uart.html">Bitvis VIP UART</a></li>
<li class="toctree-l1"><a class="reference internal" href="vip_wishbone.html">Bitvis VIP Wishbone</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">UVVM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>VVC Framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/vvc_framework.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vvc-framework">
<span id="id1"></span><h1>VVC Framework<a class="headerlink" href="#vvc-framework" title="Permalink to this headline">¶</a></h1>
<div class="section" id="common-vvc-methods">
<span id="vvc-framework-methods"></span><h2>Common VVC Methods<a class="headerlink" href="#common-vvc-methods" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>All VVC procedures are defined in td_vvc_framework_common_methods_pkg.vhd and ti_vvc_framework_support_pkg.vhd</p></li>
<li><p>All parameters in brackets are optional.</p></li>
</ul>
<div class="section" id="await-completion">
<h3>await_completion()<a class="headerlink" href="#await-completion" title="Permalink to this headline">¶</a></h3>
<p>Tells the VVC to await the completion of either all pending commands or a specified command index. A message will be logged before
and at the end of the wait. The procedure will report an alert if not all commands have completed within the specified timeout.
The severity of this alert will be TB_ERROR. It is also possible to <a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<p>To await the completion of one out of several VVCs in a group use the overload with the vvc_info_list. The vvc_info_list of type
<a class="reference internal" href="protected_types.html#t-vvc-info-list"><span class="std std-ref">t_vvc_info_list</span></a> (protected type) is a local variable that needs to be declared in the sequencer. This overload will block
the sequencer while waiting, but not the VVCs, so they can continue to receive commands from other sequencers.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul class="simple">
<li><p>To use the vvc_info_list, the package <code class="docutils literal notranslate"><span class="pre">uvvm_vvc_framework.ti_protected_types_pkg.all</span></code> must be included in the testbench.</p></li>
<li><p>The command with the vvc_info_list requires VVCs supporting the VVC activity register introduced in UVVM release v2020.05.19</p></li>
</ul>
</div>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Old method</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="p">[</span><span class="n">wanted_idx</span><span class="p">],</span> <span class="n">timeout</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>

<span class="c1">-- New method</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">vvc_select</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_info_list</span><span class="p">],</span> <span class="n">timeout</span><span class="p">,</span> <span class="p">[</span><span class="n">list_action</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_select</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-vvc-select"><span class="std std-ref">t_vvc_select</span></a></p></td>
<td><p>Selects whether to await for any of the VVCs in the
list, all of the VVCs in the list or all the registered
VVCs in the testbench (broadcast)</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_info_list</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="protected_types.html#t-vvc-info-list"><span class="std std-ref">t_vvc_info_list</span></a></p></td>
<td><p>A list of protected type containing one or several VVC
IDs (name, instance, channel) &amp; command index. VVC IDs
and corresponding command index can be added to the list
by using the procedure add() from the
<a class="reference internal" href="protected_types.html#t-vvc-info-list"><span class="std std-ref">t_vvc_info_list</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>timeout</p></td>
<td><p>in</p></td>
<td><p>time</p></td>
<td><p>The maximum time to await completion of a specified
command, or all pending commands. An alert of severity
ERROR will be triggered if the awaited time is equal to
the specified timeout.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>wanted_idx</p></td>
<td><p>in</p></td>
<td><p>natural</p></td>
<td><p>The index to be fetched or awaited</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>list_action</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-list-action"><span class="std std-ref">t_list_action</span></a></p></td>
<td><p>An enumerated type to either keep the VVC IDs or remove
them from the list after await_completion() has
finished. Default value is CLEAR_LIST.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples (old method):</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Wait for SBI instance 1 to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_cmd_idx</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Wait for sbi_read to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Multicast:</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Wait for all SBI instances to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Wait for all UART channels from instance 1 to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="mi">1</span> <span class="n">ms</span><span class="p">,</span> <span class="s">&quot;Wait for all the VVCs to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">)</span>

<span class="c1">-- Examples (new method):</span>
<span class="k">variable</span> <span class="n">my_vvc_info_list</span> <span class="o">:</span> <span class="n">t_vvc_info_list</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">my_vvc_info_list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;SBI_VVC&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">my_vvc_info_list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;AXISTREAM_VVC&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">v_cmd_idx</span><span class="p">);</span>
<span class="n">my_vvc_info_list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;UART_VVC&quot;</span><span class="p">,</span> <span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">);</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">ANY_OF</span><span class="p">,</span> <span class="n">my_vvc_info_list</span><span class="p">,</span> <span class="mi">1</span> <span class="n">ms</span><span class="p">,</span> <span class="n">KEEP_LIST</span><span class="p">,</span> <span class="s">&quot;Wait for any VVC in the list to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">ALL_VVCS</span><span class="p">,</span> <span class="mi">1</span> <span class="n">ms</span><span class="p">,</span> <span class="n">CLEAR_LIST</span><span class="p">,</span> <span class="s">&quot;Wait for all the VVCs to finish&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="await-any-completion">
<h3>await_any_completion()<a class="headerlink" href="#await-any-completion" title="Permalink to this headline">¶</a></h3>
<p>Replaced by <code class="docutils literal notranslate"><span class="pre">await_completion(ANY_OF,</span> <span class="pre">vvc_info_list,</span> <span class="pre">timeout,</span> <span class="pre">list_action,</span> <span class="pre">msg,</span> <span class="pre">scope)</span></code> above to allow VVCs to accept commands
while waiting for completion. This command still works as previously, but with less functionality than the new
<code class="docutils literal notranslate"><span class="pre">await_completion()</span></code>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">await_any_completion</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="p">[</span><span class="n">wanted_idx</span><span class="p">],</span> <span class="n">lastness</span><span class="p">,</span> <span class="p">[</span><span class="n">timeout</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">awaiting_completion_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]]])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This procedure will soon be deprecated and removed. For details and examples for using this call see UVVM release v2020.05.12
or any earlier releases.</p>
</div>
</div>
<div class="section" id="enable-log-msg">
<h3>enable_log_msg()<a class="headerlink" href="#enable-log-msg" title="Permalink to this headline">¶</a></h3>
<p>Instructs the VVC to enable a given log ID. This call will be forwarded to the UVVM Utility Library <a class="reference internal" href="utility_library.html#util-enable-log-msg"><span class="std std-ref">enable_log_msg()</span></a>
function. It is also possible to <a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">enable_log_msg</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="n">msg_id</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">quietness</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">msg_id</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">quietness</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id</p></td>
<td><p>in</p></td>
<td><p>t_msg_id</p></td>
<td><p>The ID to enable/disable with enable/disable_log_msg().
For more info, see the UVVM-Util documentation.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>quietness</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-quietness"><span class="std std-ref">t_quietness</span></a></p></td>
<td><p>Logging of this procedure can be turned off by setting
quietness=QUIET. Default value is NON_QUIET.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ID_LOG_BFM</span><span class="p">,</span> <span class="s">&quot;Enabling SBI BFM logging&quot;</span><span class="p">);</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TX</span><span class="p">,</span> <span class="n">ID_LOG_BFM</span><span class="p">,</span> <span class="s">&quot;Enabling UART TX BFM logging&quot;</span><span class="p">,</span> <span class="n">NON_QUIET</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">ID_LOG_BFM</span><span class="p">,</span> <span class="s">&quot;Enabling BFM logging for all VVCs&quot;</span><span class="p">,</span> <span class="n">NON_QUIET</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="disable-log-msg">
<h3>disable_log_msg()<a class="headerlink" href="#disable-log-msg" title="Permalink to this headline">¶</a></h3>
<p>Instructs the VVC to disable a given log ID. This call will be forwarded to the UVVM Utility Library <a class="reference internal" href="utility_library.html#util-disable-log-msg"><span class="std std-ref">disable_log_msg()</span></a>
function. It is also possible to <a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">disable_log_msg</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="n">msg_id</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">quietness</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">msg_id</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">quietness</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg_id</p></td>
<td><p>in</p></td>
<td><p>t_msg_id</p></td>
<td><p>The ID to enable/disable with enable/disable_log_msg().
For more info, see the UVVM-Util documentation.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>quietness</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-quietness"><span class="std std-ref">t_quietness</span></a></p></td>
<td><p>Logging of this procedure can be turned off by setting
quietness=QUIET. Default value is NON_QUIET.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ID_LOG_BFM</span><span class="p">,</span> <span class="s">&quot;Disabling SBI BFM logging&quot;</span><span class="p">);</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TX</span><span class="p">,</span> <span class="n">ID_LOG_BFM</span><span class="p">,</span> <span class="s">&quot;Disabling UART TX BFM logging&quot;</span><span class="p">,</span> <span class="n">NON_QUIET</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">ALL_MESSAGES</span><span class="p">,</span> <span class="s">&quot;Disables all messages in all VVCs&quot;</span><span class="p">,</span> <span class="n">NON_QUIET</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="flush-command-queue">
<h3>flush_command_queue()<a class="headerlink" href="#flush-command-queue" title="Permalink to this headline">¶</a></h3>
<p>Flushes the VVC command queue for the specified VVC target/channel. The procedure will log information with log ID ID_IMMEDIATE_CMD.
It is also possible to <a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">flush_command_queue</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">flush_command_queue</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">flush_command_queue</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Flushing command queue&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">flush_command_queue</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="s">&quot;Flushing command queues&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="fetch-result">
<h3>fetch_result()<a class="headerlink" href="#fetch-result" title="Permalink to this headline">¶</a></h3>
<p>Fetches a stored result using the command index. A result is stored when using e.g. the read or receive commands in a VVC. The
fetched result is available on the <em>result</em> output. The Boolean output <em>fetch_is_accepted</em> is used to indicate if the fetch was
successful or not. A fetch can fail if e.g. the wanted_idx did not have a result to store, or the wanted_idx read has not yet been
executed. Omitting the <em>fetch_is_accepted</em> parameter causes the parameters to be checked automatically in the procedure. On
successful fetch, a message with log ID ID_UVVM_CMD_RESULT is logged.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">fetch_result</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="n">wanted_idx</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="p">[</span><span class="n">fetch_is_accepted</span><span class="p">],</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">alert_level</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>wanted_idx</p></td>
<td><p>in</p></td>
<td><p>natural</p></td>
<td><p>The index to be fetched or awaited</p></td>
</tr>
<tr class="row-even"><td><p>variable</p></td>
<td><p>result</p></td>
<td><p>out</p></td>
<td><p>t_vvc_result</p></td>
<td><p>The output where the fetched data is to be placed</p></td>
</tr>
<tr class="row-odd"><td><p>variable</p></td>
<td><p>fetch_is_accepted</p></td>
<td><p>out</p></td>
<td><p>boolean</p></td>
<td><p>Whether the fetch command was accepted or not. Will be
false if the specified command idx has not been stored.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>alert_level</p></td>
<td><p>in</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>The alert level used when the command is not accepted.
Default value is TB_ERROR.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">v_cmd_idx</span><span class="p">,</span> <span class="n">v_data</span><span class="p">,</span> <span class="n">v_is_ok</span><span class="p">,</span> <span class="s">&quot;Fetching read-result&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Full example:</span>
<span class="n">sbi_read</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">C_ADDR_FIFO_GET</span><span class="p">,</span> <span class="s">&quot;Read from FIFO&quot;</span><span class="p">);</span>
<span class="n">v_cmd_idx</span> <span class="o">:=</span> <span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">-- Retrieve the command index</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_cmd_idx</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Wait for sbi_read to finish&quot;</span><span class="p">);</span>
<span class="n">fetch_result</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_cmd_idx</span><span class="p">,</span> <span class="n">v_data</span><span class="p">,</span> <span class="n">v_is_ok</span><span class="p">,</span> <span class="s">&quot;Fetching read-result&quot;</span><span class="p">);</span>
<span class="n">check_value</span><span class="p">(</span><span class="n">v_is_ok</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="s">&quot;Readback OK via fetch_result()&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="insert-delay">
<h3>insert_delay()<a class="headerlink" href="#insert-delay" title="Permalink to this headline">¶</a></h3>
<p>Inserts a delay of <em>delay</em> clock cycles or <em>delay</em> seconds in the VVC. It is also possible to
<a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">insert_delay</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="n">delay</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">insert_delay</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>delay</p></td>
<td><p>in</p></td>
<td><p>time or natural</p></td>
<td><p>Delay to be inserted as time or number of clock cycles</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">insert_delay</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;50 ns delay&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
<span class="n">insert_delay</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&quot;100T delay&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">insert_delay</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="mi">50</span> <span class="n">ns</span><span class="p">,</span> <span class="s">&quot;Insert 50 ns delay to all VVCs&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="terminate-current-command">
<h3>terminate_current_command()<a class="headerlink" href="#terminate-current-command" title="Permalink to this headline">¶</a></h3>
<p>Terminates the current command in the VVC, if the currently running BFM command supports the terminate signal. It is also possible
to <a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">terminate_current_command</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">terminate_current_command</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">terminate_current_command</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Terminating current command&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">terminate_current_command</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="s">&quot;Terminating current command in all VVCs&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="terminate-all-commands">
<h3>terminate_all_commands()<a class="headerlink" href="#terminate-all-commands" title="Permalink to this headline">¶</a></h3>
<p>Terminates the current command in the VVC, if the currently running BFM command supports the terminate signal. The procedure also
flushes the VVC command queue, removing all pending commands. It is also possible to
<a class="reference internal" href="#vvc-framework-broadcasting"><span class="std std-ref">broadcast and multicast</span></a>.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">terminate_all_commands</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">],</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
<span class="n">terminate_all_commands</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="p">[</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>msg</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>A custom message to be appended to the log when the
method is executed. Default value is “”.</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">terminate_all_commands</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Terminating all commands&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>

<span class="c1">-- Broadcast:</span>
<span class="n">terminate_all_commands</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="s">&quot;Terminating all commands in all VVCs&quot;</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="get-last-received-cmd-idx">
<h3>get_last_received_cmd_idx()<a class="headerlink" href="#get-last-received-cmd-idx" title="Permalink to this headline">¶</a></h3>
<p>Gets the command index of the last command received by the VVC interpreter. Necessary for getting the command index of a read for
fetch_result.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">vvc_target</span><span class="p">,</span> <span class="n">vvc_instance_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">vvc_channel</span><span class="p">,</span> <span class="p">[</span><span class="n">scope</span><span class="p">]])</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Dir.</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signal</p></td>
<td><p>vvc_target</p></td>
<td><p>inout</p></td>
<td><p>t_vvc_target_record</p></td>
<td><p>VVC target type compiled into each VVC in order to
differentiate between VVCs</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>vvc_instance_idx</p></td>
<td><p>in</p></td>
<td><p>integer</p></td>
<td><p>Instance number of the VVC used in this method</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>vvc_channel</p></td>
<td><p>in</p></td>
<td><p>t_channel</p></td>
<td><p>The VVC channel of the VVC instance used in this method</p></td>
</tr>
<tr class="row-odd"><td><p>constant</p></td>
<td><p>scope</p></td>
<td><p>in</p></td>
<td><p>string</p></td>
<td><p>Describes the scope from which the log/alert originates.
Default value is C_VVC_CMD_SCOPE_DEFAULT.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">v_cmd_idx</span> <span class="o">:=</span> <span class="n">get_last_received_cmd_idx</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">C_SCOPE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="broadcasting-and-multicasting">
<span id="vvc-framework-broadcasting"></span><h3>Broadcasting and Multicasting<a class="headerlink" href="#broadcasting-and-multicasting" title="Permalink to this headline">¶</a></h3>
<p>Commands in UVVM can be distributed to all instances of a VVC or to all VVCs using dedicated parameters.</p>
<div class="section" id="vvc-broadcast">
<h4>VVC_BROADCAST<a class="headerlink" href="#vvc-broadcast" title="Permalink to this headline">¶</a></h4>
<p>The VVC_BROADCAST command parameter can be used when a command is to target all VVCs within the test environment, reducing the
number of command instructions needed in the testbench.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">ALL_MESSAGES</span><span class="p">);</span> <span class="c1">-- enable logging for all VVCs</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="mi">10</span> <span class="n">us</span><span class="p">);</span> <span class="c1">-- wait for all VVCs to complete</span>
</pre></div>
</div>
</div>
<div class="section" id="all-instances">
<h4>ALL_INSTANCES<a class="headerlink" href="#all-instances" title="Permalink to this headline">¶</a></h4>
<p>The ALL_INSTANCES command parameter can be used when a command is targeting all instances of a VVC within the test environment,
reducing the number of command instructions needed in the testbench.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="n">ALL_MESSAGES</span><span class="p">);</span> <span class="c1">-- enable logging for all instances of SBI_VVCT</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">SBI_VVCT</span><span class="p">,</span> <span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">);</span> <span class="c1">-- wait for all instances of SBI_VVCT to complete</span>
</pre></div>
</div>
</div>
<div class="section" id="all-channels">
<h4>ALL_CHANNELS<a class="headerlink" href="#all-channels" title="Permalink to this headline">¶</a></h4>
<p>The ALL_CHANNELS command parameter can be used when a command is targeting all channels of a VVC within the test environment,
reducing the number of command instructions needed in the testbench.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Examples:</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">,</span> <span class="n">ALL_MESSAGES</span><span class="p">);</span> <span class="c1">-- enable logging for all channels of UART_VVCT instance 1</span>
<span class="n">await_completion</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span> <span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">,</span> <span class="mi">100</span> <span class="n">ns</span><span class="p">);</span> <span class="c1">-- wait for all instances and channels of UART_VVCT to complete</span>
</pre></div>
</div>
</div>
<div class="section" id="c-vvct-all-instances">
<h4>C_VVCT_ALL_INSTANCES<a class="headerlink" href="#c-vvct-all-instances" title="Permalink to this headline">¶</a></h4>
<p>See description above. C_VVCT_ALL_INSTANCES = ALL_INSTANCES.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This command parameter might be removed in a future release and we encourage the use of ALL_INSTANCES.</p>
</div>
</div>
</div>
</div>
<div class="section" id="essential-mechanisms">
<span id="vvc-framework-essential-mechanisms"></span><h2>Essential Mechanisms<a class="headerlink" href="#essential-mechanisms" title="Permalink to this headline">¶</a></h2>
<p>This section explains some of the essential mechanisms necessary for running VVC Framework, in addition to helpful and important
VVC status and configuration records which are accessible directly from the testbench.
More details on the VVC Framework and the command mechanism can be found in the
<a class="reference external" href="https://github.com/UVVM/UVVM/tree/master/uvvm_vvc_framework/doc/VVC_Framework_Manual.pdf">VVC Framework Manual</a>.</p>
<div class="section" id="libraries">
<h3>Libraries<a class="headerlink" href="#libraries" title="Permalink to this headline">¶</a></h3>
<p>In order to use a VVC the following libraries need to be included:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">uvvm_util</span><span class="p">;</span>
<span class="n">context</span> <span class="n">uvvm_util</span><span class="p">.</span><span class="n">uvvm_util_context</span><span class="p">;</span>

<span class="k">library</span> <span class="nn">uvvm_vvc_framework</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">uvvm_vvc_framework.ti_vvc_framework_support_pkg.</span><span class="k">all</span><span class="p">;</span>

<span class="k">library</span> <span class="nn">bitvis_vip_</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">context</span> <span class="n">bitvis_vip_</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">.</span><span class="n">vvc_context</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="uvvm-initialization">
<h3>UVVM Initialization<a class="headerlink" href="#uvvm-initialization" title="Permalink to this headline">¶</a></h3>
<p>The following mechanisms are required for running UVVM VVC Framework:</p>
<div class="section" id="ti-uvvm-engine">
<h4>ti_uvvm_engine<a class="headerlink" href="#ti-uvvm-engine" title="Permalink to this headline">¶</a></h4>
<p>This entity contains a process that will initialize the UVVM environment, and has to be instantiated in the testbench harness, or
alternatively in the top-level testbench.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Example:</span>
<span class="n">i_ti_uvvm_engine</span> <span class="o">:</span> <span class="k">entity</span> <span class="nc">uvvm_vvc_framework</span><span class="p">.</span><span class="n">ti_uvvm_engine</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="await-uvvm-initialization">
<h4>await_uvvm_initialization()<a class="headerlink" href="#await-uvvm-initialization" title="Permalink to this headline">¶</a></h4>
<p>This procedure is a blocking procedure that has to be called from the testbench sequencer, prior to any VVC calls, to ensure that
the UVVM engine has been initialized and is ready. This procedure will check the shared_uvvm_state on each delta cycle until the
UVVM engine has been initialized. Note that this method is depending on the ti_uvvm_engine mechanism.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Example:</span>
<span class="n">await_uvvm_initialization</span><span class="p">(</span><span class="n">VOID</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="uvvm-and-vvc-user-accessible-shared-variables-and-global-signals">
<h3>UVVM and VVC User Accessible Shared Variables and Global Signals<a class="headerlink" href="#uvvm-and-vvc-user-accessible-shared-variables-and-global-signals" title="Permalink to this headline">¶</a></h3>
<p>UVVM and VVC shared variables and global signals are defined in global_signals_and_shared_variables_pkg.vhd and the various VVC
packages.</p>
<div class="section" id="shared-uvvm-status">
<h4>shared_uvvm_status<a class="headerlink" href="#shared-uvvm-status" title="Permalink to this headline">¶</a></h4>
<p>Shared variable providing access to VVC related information via the info_on_finishing_await_any_completion record element, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">shared_uvvm_status</span><span class="p">.</span><span class="n">info_on_finishing_await_any_completion</span>
</pre></div>
</div>
<p>This record element gives access to the name, command index and the time of completion of the VVC that first fulfilled the
await_any_completion(). The available record fields are:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">vvc_name</span>               <span class="o">:</span> <span class="kt">string</span>  <span class="c1">-- default &quot;no await_any_completion() yet&quot;</span>
<span class="n">vvc_cmd_idx</span>            <span class="o">:</span> <span class="kt">natural</span> <span class="c1">-- default 0</span>
<span class="n">vvc_time_of_completion</span> <span class="o">:</span> <span class="kt">time</span>    <span class="c1">-- default 0 ns</span>
</pre></div>
</div>
<p>For more information regarding other fields available in the shared_uvvm_status see <a class="reference internal" href="utility_library.html#util-shared-variables"><span class="std std-ref">UVVM Util - Shared Variables</span></a>.</p>
</div>
<div class="section" id="shared-vvc-name-vvc-config">
<h4>shared_&lt;vvc_name&gt;_vvc_config<a class="headerlink" href="#shared-vvc-name-vvc-config" title="Permalink to this headline">¶</a></h4>
<p>Shared variable providing access to configuration parameters for each VVC instance and channel if applicable, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">shared_sbi_vvc_config</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">inter_bfm_delay</span><span class="p">.</span><span class="n">delay_type</span> <span class="o">:=</span> <span class="n">TIME_START2START</span><span class="p">;</span>
<span class="n">shared_uart_vvc_config</span><span class="p">(</span><span class="n">RX</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span><span class="n">bfm_config</span><span class="p">.</span><span class="n">bit_time</span> <span class="o">:=</span> <span class="n">C_BIT_TIME</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="shared-vvc-name-vvc-status">
<h4>shared_&lt;vvc_name&gt;_vvc_status<a class="headerlink" href="#shared-vvc-name-vvc-status" title="Permalink to this headline">¶</a></h4>
<p>Shared variable providing access to status parameters for each VVC instance and channel if applicable, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">v_num_pending_cmds</span> <span class="o">:=</span> <span class="n">shared_sbi_vvc_status</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">pending_cmd_cnt</span><span class="p">;</span>
<span class="n">v_current_cmd_idx</span>  <span class="o">:=</span> <span class="n">shared_uart_vvc_status</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span><span class="mi">2</span><span class="p">).</span><span class="n">current_cmd_idx</span><span class="p">;</span>
<span class="n">v_previous_cmd_idx</span> <span class="o">:=</span> <span class="n">shared_uart_vvc_status</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span><span class="mi">2</span><span class="p">).</span><span class="n">previous_cmd_idx</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="global-vvc-name-vvc-transaction-trigger">
<h4>global_&lt;vvc_name&gt;_vvc_transaction_trigger<a class="headerlink" href="#global-vvc-name-vvc-transaction-trigger" title="Permalink to this headline">¶</a></h4>
<p>Global trigger signal for when a VVC has updated its shared variable with VVC transaction info. See
<a class="reference internal" href="#vvc-framework-transaction-info"><span class="std std-ref">Distribution of Transaction Info - From VVCs and/or Monitors</span></a> for more details.</p>
</div>
<div class="section" id="shared-vvc-name-vvc-transaction-info">
<h4>shared_&lt;vvc_name&gt;_vvc_transaction_info<a class="headerlink" href="#shared-vvc-name-vvc-transaction-info" title="Permalink to this headline">¶</a></h4>
<p>Shared variable providing access to Transaction Info VVC instances. See <a class="reference internal" href="#vvc-framework-transaction-info"><span class="std std-ref">Distribution of Transaction Info - From VVCs and/or Monitors</span></a> for more details.
Available information is dependent on VVC type and typical information is:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">operation</span>          <span class="o">:</span> <span class="n">t_operation</span><span class="p">;</span>                                            <span class="c1">-- default NO_OPERATION</span>
<span class="n">data</span>               <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">C_VVC_CMD_DATA_MAX_LENGTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">-- default 0x0</span>
<span class="n">vvc_meta</span>           <span class="o">:</span> <span class="n">t_vvc_meta</span><span class="p">;</span>                                             <span class="c1">-- default C_VVC_META_DEFAFULT</span>
<span class="n">transaction_status</span> <span class="o">:</span> <span class="n">t_transaction_status</span><span class="p">;</span>                                   <span class="c1">-- default C_TRANSACTION_STATUS_DEFAULT (INACTIVE)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This shared variable is replacing the shared_&lt;vvc_name&gt;_transaction_info, which will soon be deprecated.</p>
</div>
</div>
</div>
<div class="section" id="vvc-status-configuration-and-transaction-information">
<span id="vvc-framework-status-config-transaction-info"></span><h3>VVC Status, Configuration and Transaction Information<a class="headerlink" href="#vvc-status-configuration-and-transaction-information" title="Permalink to this headline">¶</a></h3>
<p>The VVC status, configuration and transaction information records are defined in each individual VVC methods package.</p>
<p>Each VVC instance and channel can be configured and useful information can be accessed from the testbench via dedicated shared
variables.</p>
<p>From the VVC configuration shared variable, one is given the ability to tailor each VVC to one’s needs, in addition to access the
BFM configuration record via the bfm_config identifier. In addition to BFM configuration possibility, the configuration settings
consist of command and result queue settings, BFM access separation delay and a VVC dedicated message ID panel. Note that some
BFMs require user configuration, e.g. the bit_time setting in serial interface BFMs.</p>
<p>The VVC status shared variable provide access to the command status parameters for each of the VVCs, such as the current and
previous command index, and the number of pending commands in the VVCs command queue. This provide a helpful tool, e.g. when
synchronizing VVCs in the test sequencer using the await_completion() or await_any_completion() methods.</p>
<p>When using a wave viewer during simulation, the transaction shared variable provides helpful information regarding current VVC
operation and transaction information such as address and data. Note that the accessible fields depend on the VVC and its
implementation. An example of two SBI VVCs performing FIFO write operations, followed by check operations, is shown in Figure 1.</p>
<div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="_images/transaction_info_wave_view.png"><img alt="VVC transaction info waveview" src="_images/transaction_info_wave_view.png" style="width: 800pt;" /></a>
<p class="caption"><span class="caption-text">Figure 1 VVC Transaction info example</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="activity-watchdog">
<span id="vvc-framework-activity-watchdog"></span><h3>Activity Watchdog<a class="headerlink" href="#activity-watchdog" title="Permalink to this headline">¶</a></h3>
<p>UVVM VVC Framework has an activity watchdog mechanism which all Bitvis VVCs support. All VVCs can be automatically registered in a
centralized VVC activity register at start-up and will, during simulation, update the VVC activity register with their current
activity status, i.e. ACTIVE or INACTIVE, which again is monitored by the activity watchdog. A timeout counter in the activity
watchdog will start after the last update has occurred in the VVC activity register, and the timeout counter is reset on any VVC
activity. An alert will be raised if none of the VVCs have an activity prior to the timeout counter reaching the specified timeout
value. Note that the activity watchdog will continue to monitor VVC activity, even after a timeout, until alert stop limit is
reached.</p>
<p>The activity watchdog has to be included as a concurrent procedure parallel to the testbench sequencer or in the test harness in
order to be activated. Note that the activity watchdog will raise a TB_WARNING if the number of expected VVCs does not match the
number of registered VVCs in the VVC activity register, and that leaf VVCs (e.g. channels such as UART RX and TX) are counted
individually. This checking can be disabled by setting the number of expected VVCs to 0. Also note that the total number of VVCs
registered in the VVC activity register cannot exceed the C_MAX_TB_VVC_NUM count, default set to 20 in the adaptations_pkg.vhd,
and this will result in a TB_ERROR raised by the VVC activity register.</p>
<p>Note that some VVCs should not be monitored by the activity watchdog. This currently applies to the clock generator VVC, as this
VVC may continue to be active even after all other testbench activity has stopped. This VVC will have to be included in the number
of expected VVCs registered in the VVC activity register but will not have any effect on the activity watchdog timeout counter.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>num_exp_vvc</p></td>
<td><p>natural</p></td>
<td><p>&lt;none&gt;</p></td>
<td><div class="line-block">
<div class="line">Expected number of VVCs which is expected to be registered in
the VVC activity register (including any clock generator VVC).</div>
<div class="line">Note 1: each channel is counted as an independent VVC expected
to be registered in the VVC activity register.</div>
<div class="line">Note 2: setting num_exp_vvc = 0 will disable checking of number
of expected VVCs vs actual number of VVCs registered in the VVC
activity register.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>timeout</p></td>
<td><p>time</p></td>
<td><p>&lt;none&gt;</p></td>
<td><p>Timeout value after last VVC activity.</p></td>
</tr>
<tr class="row-even"><td><p>alert_level</p></td>
<td><p><a class="reference internal" href="types_pkg.html#t-alert-level"><span class="std std-ref">t_alert_level</span></a></p></td>
<td><p>TB_ERROR</p></td>
<td><p>The timeout will have this alert level.</p></td>
</tr>
<tr class="row-odd"><td><p>msg</p></td>
<td><p>string</p></td>
<td><p>&quot;Activity Watchdog&quot;</p></td>
<td><p>Message included with activity watchdog log messages, e.g. name
of activity watchdog.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Example:</span>
<span class="n">p_activity_watchdog</span><span class="o">:</span>
    <span class="n">activity_watchdog</span><span class="p">(</span><span class="n">num_exp_vvc</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=&gt;</span> <span class="n">C_ACTIVITY_WATCHDOG_TIMEOUT</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="distribution-of-transaction-info-from-vvcs-and-or-monitors">
<span id="vvc-framework-transaction-info"></span><h3>Distribution of Transaction Info - From VVCs and/or Monitors<a class="headerlink" href="#distribution-of-transaction-info-from-vvcs-and-or-monitors" title="Permalink to this headline">¶</a></h3>
<p>UVVM supports sharing transaction information in a controlled manner within the complete testbench environment. This allows VVCs
and Monitors to provide transaction info to any other part of your testbench – using a predefined structured mechanism. This makes
it even easier to make good VHDL testbenches.</p>
<p>Transaction information may be used in many different ways, but the main purpose is to share information inside the testbench of
activity or accesses on a given DUT interface. Such information could typically be provided from a dedicated interface Monitor,
but making such a dedicated Monitor is sometimes quite time consuming and often not really needed. For that reason, UVVM provides
a mechanism for getting the transaction information directly from the VVC.</p>
<div class="section" id="purpose">
<span id="vvc-framework-transaction-info-purpose"></span><h4>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h4>
<p>By enabling the distribution of transaction info, models or any other parts of the testbench can see exactly what accesses have
been made on the various interfaces of the DUT, so that the expected DUT behaviour and outputs may be checked. Let us illustrate
this with a really simple testbench scenario to verify a UART peripheral with an AXI-lite register/CPU interface on one side and
the UART RX and TX ports on the other side. The test sequencer may command the AXI-lite BFM or VVC to write a data byte into the
UART TX register, and then it must be checked that the data byte is transmitted out on the DUT TX output some time later.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>A simple testbench approach could be to have the test sequencer also telling the receiving UART BFM or VVC exactly what to
expect. This is a straightforward approach, but requires more action and data control inside the test sequencer. This could
of course all be handled in a super-procedure, but for any undetermined behaviour inside the BFM or VVC, like random data
generation or error injection, that would not work. See Figure 2.</p></li>
<li><p>A more advanced approach is to have a model overlooking the DUT accesses, generate the expected data and tell the receiving
BFM or VVC to check for that data. See Figure 3.</p></li>
<li><p>An even more advanced approach would be to use a Scoreboard to check received data (from DUT via VVC) against expected data
from a model. See Figure 4.</p></li>
</ol>
</div></blockquote>
<p>However, for the two latter approaches the model needs information about exactly what happened (the transaction) on the various
DUT interfaces, so that it can generate the correct expected data. For the model it doesn’t matter if the transaction info comes
from a Monitor or from a VVC, as long as the information is correct.</p>
<p>The model could of course look at the interfaces and analyse the actual transactions, but distributing this task to the VVC or
Monitor makes the testbench far more structured and significantly improves overview, maintenance, extensibility and reuse – at
least for anything above medium simple verification challenges.</p>
<p>Another purpose of providing transaction information is for progress viewing and debugging – typically via the wave view or
simulation transcripts.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="figure align-center" id="id10">
<img alt="Direct transaction transfer A" src="_images/direct_transaction_transfer_example_A.png" />
<p class="caption"><span class="caption-text">Figure 2 Distribution of Transaction Info Approach A</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
</td>
<td><div class="figure align-center" id="id11">
<img alt="Direct transaction transfer B" src="_images/direct_transaction_transfer_example_B.png" />
<p class="caption"><span class="caption-text">Figure 3 Distribution of Transaction Info Approach B</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
</td>
<td><div class="figure align-center" id="id12">
<img alt="Direct transaction transfer C" src="_images/direct_transaction_transfer_example_C.png" />
<p class="caption"><span class="caption-text">Figure 4 Distribution of Transaction Info Approach C</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="transaction-definitions">
<span id="vvc-framework-transaction-info-definitions"></span><h4>Transaction definitions<a class="headerlink" href="#transaction-definitions" title="Permalink to this headline">¶</a></h4>
<p>By transactions we normally talk about a complete end to end transfer of data across an interface. This could be anything from a
simple write, read or transfer of a single word - to a complete packet in a packet-oriented protocol like Ethernet. The word
transaction is however also used for both sub-sets and super-sets of this – depending on the protocol and even on how we want to
control our system or testbench. In order to communicate properly and to assure that transactions are properly understood, the
following terms are defined:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Base transaction (BT)</strong> is the lowest level of a complete transaction as allowed from the central sequencer. E.g.
AXI-lite, UART, Ethernet and AXI-Stream transactions.</p></li>
<li><p><strong>Sub-transaction (ST)</strong> is the lowest level of an incomplete transaction as allowed from a BFM. The sub-transaction as such
is complete seen from a handshake point of view, but the transfer of data is not complete. A split transaction protocol will
typically have sub-transactions. E.g. Avalon Read Request and Avalon Read Response.</p></li>
<li><p><strong>Leaf transaction (LT)</strong> is not a transaction type in itself, but is the lowest level of complete or incomplete transaction
defined for a given protocol. I.e. a sub-transaction when this is defined for a given protocol, otherwise a base transaction.
This definition is needed in order simplify various explanations. E.g. for Avalon: LT = the sub transactions, and for UART,
SBI or Ethernet: LT = the base transactions (as no sub-transaction exist for these protocols)</p></li>
<li><p><strong>Compound transaction (CT)</strong> is a set of transactions or other methods or statements that as a total is doing a more
complex operation. A compound transaction involves calling multiple base transactions. E.g. sbi_poll_until() or a UART
transmit of N consecutive bytes. No compound transaction needs to be defined.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="transaction-information">
<h4>Transaction information<a class="headerlink" href="#transaction-information" title="Permalink to this headline">¶</a></h4>
<p>Information about the above transactions is typically provided to a model in the test harness. Depending on whether the
transaction info is provided from the VVC or Monitor, different types of information will be available. Common for both is that
they always provide info about the operation (read, write, transmit, etc.) and often also any other protocol specific info. For a
UART this could be data and parity, for an SBI it could be address and data, and for Ethernet, the packet fields.</p>
<p>This minimum is normally what the Monitor can provide from just analysing the interface, and this is also normally enough for a
model to generate expected DUT outputs. The VVC on the other hand, can provide more info, which could be useful for instance for
progress viewing and debugging.</p>
<p>The transaction information is organised as a transaction record with some predefined fields as shown below. Table 1 shows the
general transaction record, whereas table 2 shows a concrete example for the SBI.</p>
<p>Note that for a given interface/protocol, the VVC and the Monitor will use the same interface dedicated transaction record type -
with some fields potentially unused.</p>
<table class="docutils align-default" id="id13">
<caption><span class="caption-text">Table 1 - General transaction record t_transaction. The fields in bold indicate optional or protocol dedicated fields</span><a class="headerlink" href="#id13" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>operation</p></td>
<td><p>t_operation</p></td>
<td><div class="line-block">
<div class="line">Protocol operation on the given DUT interface. E.g. NO_OPERATION,
WRITE, READ, TRANSMIT, POLL_UNTIL, …</div>
<div class="line">NO_OPERATION is default and thus used when there is no access.</div>
<div class="line">All operations will be separated with a NO_OPERATION for at least
1 delta cycle, e.g. NO_OPERATION - WRITE - NO_OPERATION - READ -
NO_OPERATION.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line"><strong>&lt;optional protocol</strong></div>
<div class="line"><strong>dedicated
field(s)&gt;</strong></div>
</div>
</td>
<td><p><strong>&lt;protocol dedicated&gt;</strong></p></td>
<td><div class="line-block">
<div class="line">One or more fields required to complete the transaction info.</div>
<div class="line">E.g. for UART: single field ‘data’; for SBI: field 1: ‘addr’,
field 2: ‘data’; for Ethernet: most Ethernet fields as separate
fields, or a better solution, include as a complete sub-record.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>transaction_status</p></td>
<td><p>t_transaction_status</p></td>
<td><div class="line-block">
<div class="line">Handled slightly different from a VVC and a Monitor.</div>
<div class="line">VVC: Will show ‘IN_PROGRESS’ during the transaction and INACTIVE
in between (for at least one delta cycle).</div>
<div class="line">Monitor: Will show FAILED or SUCCEEDED immediately as soon as
this is 100% certain - and keep this info for the display period
defined in the Monitor configuration record, or until the start
of the next transaction,</div>
<div class="line">whichever occurs first. Other than that, it will show IN_PROGRESS
when active or INACTIVE when not.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>vvc_meta</p></td>
<td><p>t_vvc_meta</p></td>
<td><p>Additional transaction information - only known by the VVC. So far
‘msg’ and ‘cmd_idx’ (the free running command index). A Monitor has
no knowledge of this and will set them to msg = “”, cmd_idx = -1</p></td>
</tr>
<tr class="row-even"><td><p><strong>error_info</strong></p></td>
<td><p><strong>t_error_info</strong></p></td>
<td><p>Any type of error injection relevant for the given protocol.
Typically parity or stop-bit error in an UART or a CRC error in an
Ethernet. If no error injection or detection has been implemented,
this sub-record may be left out.</p></td>
</tr>
<tr class="row-odd"><td colspan="3"><div class="line-block">
<div class="line"><em>Note: For transaction info from a VVC, the record reflects the command status, i.e. the status assumed by the VVC when
initiating the command, whereas the Monitor will set up the record only after knowing whether the transaction has failed
or succeeded.</em></div>
<div class="line"><em>The VVC does not know the BFM status, and this is fine because the BFM will issue an alert for unexpected behaviour.</em></div>
</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id14">
<caption><span class="caption-text">Table 2 - SBI specific transaction record t_transaction. The fields in bold indicate protocol dedicated fields</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>operation</p></td>
<td><p>t_operation</p></td>
<td><p>Either of WRITE, READ or CHECK, but could also be POLL_UNTIL or a
more complex compound transaction</p></td>
</tr>
<tr class="row-odd"><td><p><strong>address</strong></p></td>
<td><p><strong>unsigned</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>data</strong></p></td>
<td><p><strong>std_logic_vector</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>transaction_status</p></td>
<td><p>t_transaction_status</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>vvc_meta</p></td>
<td><p>t_vvc_meta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="3"><p><em>Note: No error_info field as no error injection or detection has been implemented in neither VVC nor Monitor - at this
stage.</em></p></td>
</tr>
</tbody>
</table>
<p>Other interfaces will of course have different protocol dedicated fields, or even a complete protocol dedicated sub-record (e.g.
for Ethernet packet fields).</p>
</div>
<div class="section" id="transaction-info-transfer">
<h4>Transaction Info transfer<a class="headerlink" href="#transaction-info-transfer" title="Permalink to this headline">¶</a></h4>
<p>In order to reduce the number of signals from a VVC or Monitor, all possible simultaneous transactions (and their transaction
records) are collected into a single transaction group record. For an SBI interface, this will consist of a BT record and
potentially a CT record. Whereas for an Avalon, it will in addition also consist of two ST records, because for instance a read
request may be active at the same time as a read response. (And the sub-transactions are part of a base transaction and may also
be part of a CT).</p>
<p>Table 3 shows the maximum transaction group record for an SBI, whereas Table 4 shows the maximum transaction group record for an
Avalon. The bold CT is optional for both, and thus depends on whether CTs have been defined in the VVC. Multiple parallel STs may
be written to the transaction group record simultaneously - as these are handled by different “threads” (concurrent statements
like a process).</p>
<p>A Monitor cannot know about CTs, and thus a Monitor will never fill in that sub-record. A Monitor for a split transaction protocol
(i.e. with multiple STs) may or may not provide BT info. If it does, this should normally be implemented in a higher level
“wrapper”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>A VVC will update its Transaction Info leaf transaction details at the start of the transaction when the BFM is called. and
turned off when BFM is finished.</p></li>
<li><p>A Monitor will set its Transaction Info record after the transaction is finished (or transaction status is known) and keep
it on for a pre-defined time - or until the next transaction is finished if earlier.</p></li>
</ul>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>It is recommended that the model (or any other user of Transaction Info) triggers on the VVC/Monitor trigger signal and checks
when transaction_status is changing to ‘INACTIVE’ and then sample &lt;signal&gt;’last_value.</p>
</div>
<table class="docutils align-default" id="id15">
<caption><span class="caption-text">Table 3 - Maximum transaction group record t_transaction_group - for an SBI interface</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bt</p></td>
<td><p>t_transaction</p></td>
<td><p>Base transaction</p></td>
</tr>
<tr class="row-odd"><td><p><strong>ct</strong></p></td>
<td><p><strong>t_transaction</strong></p></td>
<td><p>Compound transaction</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id16">
<caption><span class="caption-text">Table 4 - Maximum transaction group record t_transaction_group - for an Avalon MM interface</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>st_request</p></td>
<td><p>t_transaction</p></td>
<td><p>Sub-transaction</p></td>
</tr>
<tr class="row-odd"><td><p>st_response</p></td>
<td><p>t_transaction</p></td>
<td><p>Sub-transaction</p></td>
</tr>
<tr class="row-even"><td><p>bt</p></td>
<td><p>t_transaction</p></td>
<td><p>Base transaction</p></td>
</tr>
<tr class="row-odd"><td><p><strong>ct</strong></p></td>
<td><p><strong>t_transaction</strong></p></td>
<td><p>Compound transaction</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="transaction-info-record-signals">
<span id="vvc-framework-transaction-info-record"></span><h4>Transaction Info record signals<a class="headerlink" href="#transaction-info-record-signals" title="Permalink to this headline">¶</a></h4>
<p>The Transaction Info record is provided out of the VVC and Monitor using sets of a global signal and a shared variable. These and
all Transaction Info related VHDL types are defined in transaction_pkg.vhd, located in the VIP src folder.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Monitor trigger signal</strong> : <em>global_&lt;protocol-name&gt;_monitor_transaction_trigger</em>, e.g. global_uart_monitor_transaction_trigger</p></li>
<li><p><strong>Monitor shared variable</strong> : <em>shared_&lt;protocol-name&gt;_monitor_transaction_info</em>, e.g. shared_uart_monitor_transaction_info</p></li>
<li><p><strong>VVC trigger signal</strong>: <em>global_&lt;protocol-name&gt;_vvc_transaction_trigger</em>, e.g. global_uart_vvc_transaction_trigger.</p></li>
<li><p><strong>VVC shared variable</strong> : <em>shared_&lt;protocol-name&gt;_vvc_transaction_info</em>, e.g, shared_uart_vvc_transaction_info. The VVC is
also responsible for filling out the vvc_meta record field.</p></li>
</ul>
</div></blockquote>
<table class="docutils align-default" id="id17">
<caption><span class="caption-text">Table 5 - Transaction Info record <strong>t_&lt;if&gt;_transaction_group</strong> for an UART interface - accessible via
       <strong>shared_uart_vvc_transaction_info(vvc_idx)</strong> t_uart_transaction_group_array</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 14%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bt</p></td>
<td><p>t_transaction</p></td>
<td><p>C_TRANSACTION_SET_DEFAULT</p></td>
<td><p>Transaction Info record entry for base transaction</p></td>
</tr>
<tr class="row-odd"><td><p>-&gt; operation</p></td>
<td><p>t_operation</p></td>
<td><p>NO_OPERATION</p></td>
<td><p>Equal to VVC transaction operation, e.g. TRANSMIT, RECEIVE and
EXPECT (UART)</p></td>
</tr>
<tr class="row-even"><td><p>-&gt; address <a class="footnote-reference brackets" href="#f1" id="id2">1</a></p></td>
<td><p>unsigned</p></td>
<td><p>0x0</p></td>
<td><p>DUT access read or write address</p></td>
</tr>
<tr class="row-odd"><td><p>-&gt; data</p></td>
<td><p>std_logic_vector</p></td>
<td><p>0x0</p></td>
<td><p>DUT read or write data</p></td>
</tr>
<tr class="row-even"><td><p>-&gt; vvc_meta</p></td>
<td><p>t_vvc_meta</p></td>
<td><p>C_VVC_META_DEFAULT</p></td>
<td><p>Record of meta data belonging to VVC command request resulting
in this base transaction</p></td>
</tr>
<tr class="row-odd"><td><p>—&gt; msg</p></td>
<td><p>string</p></td>
<td><p>“”</p></td>
<td><p>Message transmitted with VVC command resulting in this base
transaction</p></td>
</tr>
<tr class="row-even"><td><p>—&gt; cmd_idx</p></td>
<td><p>integer</p></td>
<td><p>-1</p></td>
<td><p>VVC command index resulting in this base transaction</p></td>
</tr>
<tr class="row-odd"><td><p>-&gt; transaction_status</p></td>
<td><p>t_transaction_status</p></td>
<td><p>C_TRANSACTION_STATUS_DEFAULT</p></td>
<td><p>The current status of transaction. Available statuses are
INACTIVE, IN_PROGRESS, FAILED and SUCCEEDED <a class="footnote-reference brackets" href="#f2" id="id3">2</a></p></td>
</tr>
<tr class="row-even"><td><p>-&gt; error_info
<a class="footnote-reference brackets" href="#f3" id="id4">3</a></p></td>
<td><p>t_error_info</p></td>
<td><p>C_ERRO_INFO_DEFAULT</p></td>
<td><p>Record entry of errors that will be injected to the DUT access
transaction</p></td>
</tr>
<tr class="row-odd"><td><p>—&gt; parity_bit_error <a class="footnote-reference brackets" href="#f4" id="id5">4</a></p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>The DUT transaction will have a parity bit error if entry is
set to true</p></td>
</tr>
<tr class="row-even"><td><p>—&gt; stop_bir_error <a class="footnote-reference brackets" href="#f4" id="id6">4</a></p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>The DUT transaction will have a stop bit error if entry is set
to true</p></td>
</tr>
<tr class="row-odd"><td><p>ct <a class="footnote-reference brackets" href="#f5" id="id7">5</a></p></td>
<td><p>t_transaction</p></td>
<td><p>C_TRANSACTION_SET_DEFAULT</p></td>
<td><div class="line-block">
<div class="line">Transaction Info record entry for compound transaction</div>
<div class="line">Note that sub-record entries would typically have the same
entries as for a base transaction, and that this entry does
not have to be suited for all interface Transaction Info
records.</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Record field <strong>address</strong> is not applicable for all interface types, e.g. UART, and is only shown here for
informational purposes.</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Transaction status <strong>FAILED</strong> and <strong>SUCCEEDED</strong> are not applicable for VVC Transaction Info records, but will be used
for Monitor Transaction Info records.</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Record field <strong>error_info</strong> and its sub-record fields can be omitted if no error injection is implemented in the BFM.</p>
</dd>
<dt class="label" id="f4"><span class="brackets">4</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p><strong>error_info</strong> sub-record fields <strong>parity_bit_error</strong> and <strong>stop_bit_error</strong> are examples of UART error injection.</p>
</dd>
<dt class="label" id="f5"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>Record entry <strong>ct</strong> will consist of similar record fields as <strong>bt</strong>, and might not always be necessary. This applies
to record entry <strong>st</strong> as well (not shown here).</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="transaction-info-signal-and-shared-variable">
<h4>Transaction Info signal and shared variable<a class="headerlink" href="#transaction-info-signal-and-shared-variable" title="Permalink to this headline">¶</a></h4>
<p>A VVC or Monitor will trigger the global trigger signals listed in <a class="reference internal" href="#vvc-framework-transaction-info-record"><span class="std std-ref">Transaction Info record signals</span></a> when information
of a new transaction info is made available. For a VVC, the transaction info is made available prior to the corresponding bus
access, i.e. before calling the BFM method, and the global trigger signal will be pulsed for a delta cycle. The VVC will set the
transaction info back to default values immediately after the bus access has finished, but then without pulsing the global trigger
signal.</p>
<p>For a Monitor, the transaction info will be made available immediately after a bus access is completed and then the global trigger
signal will be pulsed for a delta cycle. The transaction info is valid when the global trigger signal is pulsed and is set back to
default values after a period of transaction_display_time, set in the Monitor configuration record, or when a new transaction is
started.</p>
</div>
<div class="section" id="examples-of-transaction-info-usage">
<h4>Examples of Transaction Info Usage<a class="headerlink" href="#examples-of-transaction-info-usage" title="Permalink to this headline">¶</a></h4>
<p>All important information regarding a transfer is available in the transaction info and accessible in the test environment, and
depending on one’s needs there are some recommended approaches for how to utilize the transaction info:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>For complex protocols, where several combinations of data widths and others are possible, it can be complicated for a VVC
to determine the structure and constraints of the scoreboard element. Examples of VVCs with such complex protocols are the
AXI Stream and the Avalon ST VVCs. Setting up the Scoreboard and checking of received data against expected data for such
complex protocols has to be done in the test harness, where the generic scoreboard is instantiated with a constrained
scoreboard element and where a dedicated process monitors the VVC transaction info and checks received data with the
scoreboard.</p></li>
<li><p>Transaction info can be used in a DUT Model process that monitors and decodes the actual transaction info data in the test
harness. The DUT Model will use the decoded transaction info and add expected data to the VVC scoreboard on the DUT
receiving side, e.g. to the SBI_VVC_SB while a SBI VVC is responsible for performing the DUT read access and check received
data with SBI_VVC_SB. See <a class="reference internal" href="#vvc-framework-transaction-info-purpose"><span class="std std-ref">Transaction Info Purpose</span></a>, example C, for how a
DUT Model will appear in the test harness.</p></li>
</ol>
</div></blockquote>
<div class="section" id="mechanism">
<span id="vvc-framework-transaction-info-mechanism"></span><h5>Mechanism<a class="headerlink" href="#mechanism" title="Permalink to this headline">¶</a></h5>
<p>The technique of using transaction info in the test environment, either in a VVC scoreboard support process or in a DUT Model,
involves the following 3 steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Wait for the interface trigger signal to be set.</p></li>
<li><p>Decode the base transaction info operation.</p></li>
<li><p>Execute wanted operation from the obtained transaction info.</p></li>
</ol>
</div></blockquote>
<p>A simple VVC Scoreboard Support process is presented in Figure 5, demonstrating how VVC scoreboard actions can be accomplished
using transaction info and a stand-alone process when not performed by a VVC. The same approach is shown in Figure 6 with a simple
DUT Model process, demonstrating how DUT modelling can be accomplished using transaction info and a stand-alone process. Note that
Figure 5 uses aliasing to simplify and improve code readability, while Figure 6 uses full transaction info names.</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">Figure 5 VVC Scoreboard Support – with aliasing</span><a class="headerlink" href="#id18" title="Permalink to this code">¶</a></div>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">p_vvc_sb_support</span> <span class="o">:</span> <span class="k">process</span>
  <span class="c1">-- transaction info handles</span>
  <span class="k">alias</span> <span class="n">sbi_transaction_trigger</span>     <span class="o">:</span> <span class="kt">std_logic</span> <span class="k">is</span> <span class="n">global_sbi_vvc_transaction_trigger</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">);</span>
  <span class="k">alias</span> <span class="n">sbi_transaction_info</span>        <span class="o">:</span> <span class="n">bitvis_vip_sbi</span><span class="p">.</span><span class="n">transaction_pkg</span><span class="p">.</span><span class="n">t_base_transaction</span> <span class="k">is</span> <span class="n">shared_sbi_vvc_transaction_info</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">;</span>
  <span class="k">alias</span> <span class="n">uart_rx_transaction_trigger</span> <span class="o">:</span> <span class="kt">std_logic</span> <span class="k">is</span> <span class="n">global_uart_vvc_transaction_trigger</span><span class="p">(</span><span class="n">RX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">);</span>
  <span class="k">alias</span> <span class="n">uart_rx_info</span>                <span class="o">:</span> <span class="n">bitvis_vip_uart</span><span class="p">.</span><span class="n">transaction_pkg</span><span class="p">.</span><span class="n">t_base_transaction</span> <span class="k">is</span> <span class="n">shared_uart_vvc_transaction_info</span><span class="p">(</span><span class="n">RX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">;</span>
  <span class="c1">-- helper variable</span>
  <span class="k">variable</span> <span class="n">v_sb_element</span>             <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">C_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
  <span class="k">while</span> <span class="n">true</span> <span class="k">loop</span><span class="o">:</span>

    <span class="c1">-- Wait for available transaction info</span>
    <span class="k">wait</span> <span class="k">until</span> <span class="p">(</span><span class="n">sbi_transaction_trigger</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="p">(</span><span class="n">uart_rx_transaction_trigger</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">sbi_transaction_trigger</span><span class="na">&#39;event</span> <span class="k">then</span>
      <span class="k">case</span> <span class="n">sbi_transaction_info</span><span class="p">.</span><span class="n">operation</span> <span class="k">is</span>
        <span class="k">when</span> <span class="n">READ</span> <span class="o">=&gt;</span>
          <span class="n">v_sb_element</span> <span class="o">:=</span> <span class="n">sbi_transaction_info</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">C_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">SBI_VVC_SB</span><span class="p">.</span><span class="n">check_received</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">,</span> <span class="n">v_sb_element</span><span class="p">);</span>
      <span class="k">end</span> <span class="k">case</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">uart_rx_transaction_trigger</span><span class="na">&#39;event</span> <span class="k">then</span>
      <span class="k">case</span> <span class="n">uart_rx_info</span><span class="p">.</span><span class="n">operation</span> <span class="k">is</span>
        <span class="k">when</span> <span class="n">RECEIVE</span> <span class="o">=&gt;</span>
          <span class="n">v_sb_element</span> <span class="o">:=</span> <span class="n">uart_rx_info</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">C_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">UART_VVC_SB</span><span class="p">.</span><span class="n">check_received</span><span class="p">(</span><span class="n">C_UART_VVC_1</span><span class="p">,</span> <span class="n">v_sb_element</span><span class="p">);</span>
      <span class="k">end</span> <span class="k">case</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>

  <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>
<span class="k">end</span> <span class="k">process</span> <span class="nc">p_vvc_sb_support</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Figure 5 demonstrates the setup of a VVC Scoreboard Support process that operates with the 3 steps listed in
<a class="reference internal" href="#vvc-framework-transaction-info-mechanism"><span class="std std-ref">Transaction Info Mechanism</span></a>. For simple scoreboard elements, such as std_logic_vector,
these scoreboard approaches are already performed by the VVCs.</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">Figure 6 DUT Model – no aliasing</span><a class="headerlink" href="#id19" title="Permalink to this code">¶</a></div>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">p_dut_model</span> <span class="o">:</span> <span class="k">process</span>
<span class="k">begin</span>
  <span class="k">while</span> <span class="n">true</span> <span class="k">loop</span><span class="o">:</span>

    <span class="c1">-- Wait for available transaction info</span>
    <span class="k">wait</span> <span class="k">until</span> <span class="p">(</span><span class="n">global_sbi_vvc_transaction_trigger</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="p">(</span><span class="n">global_uart_vvc_transaction_trigger</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">global_sbi_vvc_transaction_trigger</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">)</span><span class="na">&#39;event</span> <span class="k">then</span>
      <span class="k">case</span> <span class="n">shared_sbi_vvc_transaction_info</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">.</span><span class="n">operation</span> <span class="k">is</span>
        <span class="k">when</span> <span class="n">WRITE</span> <span class="o">=&gt;</span>
          <span class="n">UART_VVC_SB</span><span class="p">.</span><span class="n">add_expected</span><span class="p">(</span><span class="n">shared_sbi_vvc_transaction_info</span><span class="p">(</span><span class="n">C_SBI_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">C_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">));</span>
      <span class="k">end</span> <span class="k">case</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">global_uart_vvc_transaction_trigger</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">)</span><span class="na">&#39;event</span> <span class="k">then</span>
      <span class="k">case</span> <span class="n">shared_uart_vvc_transaction_info</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">.</span><span class="n">operation</span> <span class="k">is</span>
        <span class="k">when</span> <span class="n">TRANSMIT</span> <span class="o">=&gt;</span>
          <span class="n">SBI_VVC_SB</span><span class="p">.</span><span class="n">add_expected</span><span class="p">(</span><span class="n">shared_uart_vvc_transaction</span><span class="p">(</span><span class="n">TX</span><span class="p">,</span> <span class="n">C_UART_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">C_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">));</span>
      <span class="k">end</span> <span class="k">case</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>

  <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>
<span class="k">end</span> <span class="k">process</span> <span class="nc">p_dut_model</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Figure 6 demonstrates the setup of a DUT Model process that operates with the 3 steps listed in
<a class="reference internal" href="#vvc-framework-transaction-info-mechanism"><span class="std std-ref">Transaction Info Mechanism</span></a>. For simple scoreboard elements, such as std_logic_vector,
these scoreboard approaches are already performed by the VVCs.</p>
</div>
<div class="section" id="complex-protocols">
<h5>Complex Protocols<a class="headerlink" href="#complex-protocols" title="Permalink to this headline">¶</a></h5>
<p>For scoreboards with complex protocols, e.g. AXI Stream and Avalon ST, the same approach as listed in
<a class="reference internal" href="#vvc-framework-transaction-info-mechanism"><span class="std std-ref">Transaction Info Mechanism</span></a> applies. The only difference is that the scoreboard
element is of a more complex type, i.e. a record element. Figure 7 demonstrates a VVC scoreboard support approach using a complex
record element.</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">Figure 7 VVC Scoreboard Support – complex scoreboard element</span><a class="headerlink" href="#id20" title="Permalink to this code">¶</a></div>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- define complex Avalon ST scoreboard type</span>
<span class="k">type</span> <span class="n">t_avalon_st_element</span> <span class="k">is</span> <span class="k">record</span>
  <span class="n">channel_value</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">C_CH_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">data_array</span>    <span class="o">:</span> <span class="n">t_slv_array</span><span class="p">(</span><span class="mi">0</span> <span class="k">to</span> <span class="n">C_ARRAY_LENGTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)(</span><span class="n">C_WORD_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">end</span> <span class="k">record</span> <span class="nc">t_avalon_st_element</span><span class="p">;</span>

<span class="c1">-- create to_string() function for t_avalon_st_element</span>
<span class="k">function</span> <span class="n">avalon_st_element_to_string</span><span class="p">(</span>
  <span class="k">constant</span> <span class="n">rec_element</span> <span class="o">:</span> <span class="n">t_avalon_st_element</span>
<span class="p">)</span> <span class="k">return</span> <span class="kt">string</span> <span class="k">is</span>
<span class="k">begin</span>
  <span class="k">return</span> <span class="s">&quot;channel value: &quot;</span> <span class="o">&amp;</span> <span class="n">to_string</span><span class="p">(</span><span class="n">rec_element</span><span class="p">.</span><span class="n">channel_value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="s">&quot;, data: &quot;</span> <span class="o">&amp;</span> <span class="n">to_string</span><span class="p">(</span><span class="n">rec_element</span><span class="p">.</span><span class="n">data_array</span><span class="p">);</span>
<span class="k">end</span> <span class="k">function</span> <span class="nc">avalon_st_element_to_string</span><span class="p">;</span>

<span class="c1">-- define Avalon ST scoreboard</span>
<span class="k">package</span> <span class="n">avalon_st_sb_pkg</span> <span class="k">is</span> <span class="k">new</span> <span class="n">bitvis_vip_scoreboard</span><span class="p">.</span><span class="n">generic_sb_package</span>
<span class="k">generic</span> <span class="k">map</span><span class="p">(</span><span class="n">t_element</span>         <span class="o">=&gt;</span> <span class="n">t_avalon_st_element</span><span class="p">,</span>
            <span class="n">element_match</span>     <span class="o">=&gt;</span> <span class="s">&quot;=&quot;</span><span class="p">,</span>
            <span class="n">to_string_element</span> <span class="o">=&gt;</span> <span class="n">avalon_st_element_to_string</span><span class="p">);</span>
<span class="k">use</span> <span class="nn">avalon_st_sb_pkg.</span><span class="k">all</span><span class="p">;</span>

<span class="k">shared</span> <span class="k">variable</span> <span class="n">AVALON_ST_VVC_SB</span> <span class="o">:</span> <span class="n">avalon_st_sb_pkg</span><span class="p">.</span><span class="n">t_generic_sb</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">p_vvc_sb_support</span> <span class="o">:</span> <span class="k">process</span>
  <span class="c1">-- transaction info handles</span>
  <span class="k">alias</span> <span class="n">avalon_st_transaction_trigger</span> <span class="o">:</span> <span class="kt">std_logic</span> <span class="k">is</span> <span class="n">global_avalon_st_vvc_transaction_trigger</span><span class="p">(</span><span class="n">C_AVALON_ST_VVC_1</span><span class="p">);</span>
  <span class="k">alias</span> <span class="n">avalon_st_transaction_info</span>    <span class="o">:</span> <span class="n">bitvis_vip_avalon_st</span><span class="p">.</span><span class="n">transaction_pkg</span><span class="p">.</span><span class="n">t_base_transaction</span> <span class="k">is</span>
                                        <span class="n">shared_avalon_st_vvc_transaction_info</span><span class="p">(</span><span class="n">C_AVALON_ST_VVC_1</span><span class="p">).</span><span class="n">bt</span><span class="p">;</span>
  <span class="c1">-- helper variable</span>
  <span class="k">variable</span> <span class="n">v_sb_element</span> <span class="o">:</span> <span class="n">t_avalon_st_element</span><span class="p">;</span>
<span class="k">begin</span>
  <span class="k">while</span> <span class="n">true</span> <span class="k">loop</span><span class="o">:</span>

    <span class="c1">-- Wait for available transaction info</span>
    <span class="k">wait</span> <span class="k">until</span> <span class="n">avalon_st_transaction_trigger</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">avalon_st_transaction_trigger</span><span class="na">&#39;event</span> <span class="k">then</span>
      <span class="k">case</span> <span class="n">avalon_st_transaction_info</span><span class="p">.</span><span class="n">operation</span> <span class="k">is</span>
        <span class="k">when</span> <span class="n">RECEIVE</span> <span class="o">=&gt;</span>
          <span class="n">v_sb_element</span><span class="p">.</span><span class="n">channel_value</span> <span class="o">:=</span> <span class="n">avalon_st_transaction_info</span><span class="p">.</span><span class="n">channel_value</span><span class="p">(</span><span class="n">C_CH_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">v_sb_element</span><span class="p">.</span><span class="n">data_array</span>    <span class="o">:=</span> <span class="n">avalon_st_transaction_info</span><span class="p">.</span><span class="n">data_array</span><span class="p">(</span><span class="mi">0</span> <span class="k">to</span> <span class="n">C_ARRAY_LENGTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)(</span><span class="n">C_WORD_WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">AVALON_ST_VVC_SB</span><span class="p">.</span><span class="n">check_received</span><span class="p">(</span><span class="n">C_AVALON_ST_VVC_1</span><span class="p">,</span> <span class="n">v_sb_element</span><span class="p">);</span>
      <span class="k">end</span> <span class="k">case</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>

  <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>
<span class="k">end</span> <span class="k">process</span> <span class="nc">p_vvc_sb_support</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Figure 7 demonstrates the setup of a VVC Scoreboard Support process that operates with the 3 steps listed in
<a class="reference internal" href="#vvc-framework-transaction-info-mechanism"><span class="std std-ref">Transaction Info Mechanism</span></a>. For complex scoreboard elements, such as records, the
scoreboard package declaration, defining the shared variable and scoreboard approaches have to be performed outside the VVC.</p>
</div>
</div>
</div>
<div class="section" id="vvc-local-sequencers">
<h3>VVC Local Sequencers<a class="headerlink" href="#vvc-local-sequencers" title="Permalink to this headline">¶</a></h3>
<p>UVVM testbenches may have one or more central sequencers – also known as test sequencers or test drivers. A single test sequencer
is recommended in order to reduce complexity – as synchronization between multiple parallel test sequencer could be really complex.
UVVM does however also provide support for so called local sequencers. These sequencers will typically run inside the VVCs
executor process. The executor will typically run a single transaction via a BFM procedure towards the DUT interface, like an
sbi_write() or uart_expect() procedure. For more advanced VVCs it would however make sense to send even higher level commands to a
VVC, like requesting it to transmit N random bytes, or setting up a peripheral by writing to multiple configuration registers. In
these cases, a single command to the VVC will trigger a complete sequence of accesses towards the DUT. The code inside the VVC
executors handling these sequences are called local sequencers as they are local to the VVC and thus also improves re-use. These
sequences of transactions may also be defined as Compound Transactions (see <a class="reference internal" href="#vvc-framework-transaction-info-definitions"><span class="std std-ref">Transaction definitions</span></a>).</p>
<p>An example of a local sequencer is the randomization sequences in the UART VVC, and poll_until in the SBI VVC.</p>
<div class="section" id="local-sequencer-requirements">
<h4>Local sequencer requirements<a class="headerlink" href="#local-sequencer-requirements" title="Permalink to this headline">¶</a></h4>
<p>The following requirements should be followed when making local sequencers (basically any VVC command resulting in more than one
base transaction):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If Transaction Info is supported, then both the leaf transaction and the compound transaction info should be updated (the
latter is not required).</p></li>
<li><p>The sequence should be handled directly inside the VVC executor - and not inside the BFM (otherwise updating the leaf
transactions for Transaction Info could be difficult).</p></li>
<li><p>It should be possible to terminate the sequence immediately after each leaf (or base) transaction - on request from the
central sequencer issuing a terminate_current_command() or terminate_all_commands().</p></li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="protocol-aware-error-injection">
<h3>Protocol Aware Error Injection<a class="headerlink" href="#protocol-aware-error-injection" title="Permalink to this headline">¶</a></h3>
<p>Error injection into the DUT could be very useful in a testbench in order to test how the DUT handles interface errors when these
errors are: a) to be detected and corrected, b) detected only, and c) not detected but may or may not affect the behaviour.</p>
<p>Protocol aware error injection is defined here as intelligent error injection, given knowledge about the interface and protocol,
e.g. to inject a parity error in a protocol rather than just inverting or delaying a signal without pre-defined detailed support
to do this at the right place. The latter is supported by a dedicated “brute force” error injection VIP ‘bitvis_vip_error_injection’
in UVVM.</p>
<p>UVVM has a pre-defined methodology for handling protocol aware error injection in a structured way.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only some VVCs and BFMs currently support error injection. The principles shown for these VVCs and BFMs may be applied
directly also for user defined VIP.</p>
</div>
<div class="section" id="uvvm-error-injection-principles">
<h4>UVVM error injection principles<a class="headerlink" href="#uvvm-error-injection-principles" title="Permalink to this headline">¶</a></h4>
<p>Error injection may be applied randomly, with no limitations. For UVVM however, we recommend the following approach:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>No randomization of behaviour inside BFMs when this could affect the DUT behaviour or output (and a monitor would be
required to check the actual DUT stimuli). Hence BFM procedures should only be called with parameters explicitly defining
the interface behaviour (from the BFM side). Thus no parity error randomization inside. The only exception is for behaviour
that should not affect the DUT. Thus the position of a data bit error could be randomized inside the BFM.</p></li>
<li><p>It is recommended that more advanced VVCs include randomization - in order to distribute this away from the test sequencer
and increase the re-use value of a VVC. Thus a VVC may be told to apply say 10% parity errors for a UART_VVC transmission
into the DUT. In that case the VVC will randomly - with a 10% probability - inject a parity error into the DUT. As the VVC
uses a BFM to handle the actual interface/protocol, this means that in 10% of the BFM transmit calls the VVC will request a
parity error to be injected.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="error-injection-in-bfms">
<h4>Error injection in BFMs<a class="headerlink" href="#error-injection-in-bfms" title="Permalink to this headline">¶</a></h4>
<p>In order to simplify the specification of which errors to inject, the complete error injection specification is given as a
sub-record inside the BFM configuration. E.g. inside the UART BFM configuration the following sub-record is defined - with fields
specifying the error injection details (details given in <a class="reference internal" href="vip_uart.html#vip-uart-bfm"><span class="std std-ref">UART BFM</span></a>).</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>error_injection (fixed name, but type will differ)</dt><dd><ul>
<li><p>parity_bit_error (boolean)</p></li>
<li><p>stop_bit_error (boolean)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>In order to initiate error injection, the BFM config record must be modified and included in the BFM procedure call.</p>
</div>
<div class="section" id="error-injection-in-vvcs">
<h4>Error injection in VVCs<a class="headerlink" href="#error-injection-in-vvcs" title="Permalink to this headline">¶</a></h4>
<p>In order to simplify the specification of which errors to inject, the complete error injection specification is given as a
sub-record inside the VVC configuration (Note: not the BFM config). E.g. inside the UART VVC configuration the following
sub-record is defined - with fields specifying the error injection details (Details given in <a class="reference internal" href="vip_uart.html#vip-uart-vvc"><span class="std std-ref">UART VVC</span></a>).</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>error_injection</dt><dd><ul>
<li><p>parity_bit_error_prob (real between 0.0 and 1.0)</p></li>
<li><p>stop_bit_error_prob (real between 0.0 and 1.0)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>In order to initiate error injection, the VVC config record must be assigned the wanted values via the VVC configuration shared
variable (see <a class="reference internal" href="#vvc-framework-status-config-transaction-info"><span class="std std-ref">VVC Status, Configuration and Transaction Information</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Error injection sub-record inside the VVC configuration will override that of the BFM configuration. Any compound or more
advanced transactions may of course also request error injection directly or indirectly via the VVC command itself.</p>
</div>
</div>
<div class="section" id="naming-and-type-usage">
<h4>Naming and type usage<a class="headerlink" href="#naming-and-type-usage" title="Permalink to this headline">¶</a></h4>
<p>The error injection sub-record will be VVC and BFM dedicated, and thus any names and types may be used, and even sub-records under
‘error_injection’ is required. The VVC and BFM error injection records may differ or be the same. The only requirement is that
readability is prioritised. Values should be checked against legal ranges or values.</p>
</div>
</div>
<div class="section" id="built-in-randomization">
<h3>Built-in randomization<a class="headerlink" href="#built-in-randomization" title="Permalink to this headline">¶</a></h3>
<p>UVVM provides functions and procedures for simple generation of random numbers (real, integer, time) and vectors, described in
<a class="reference internal" href="utility_library.html#basic-randomization"><span class="std std-ref">Basic Randomization</span></a>. It also provides a more complete randomization package using protected types, which is described in
<a class="reference internal" href="rand_pkg_overview.html#rand-pkg-overview"><span class="std std-ref">Enhanced Randomization</span></a>. And a more advanced randomization without replacement, described in <a class="reference internal" href="optimized_rand.html#optimized-randomization"><span class="std std-ref">Optimized Randomization</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only some VVCs currently include built-in randomization (e.g. UART TX VVC and SBI VVC.) The principles shown for these VVCs
may be applied directly also for a user defined VIP.</p>
</div>
<div class="section" id="uvvm-vip-randomization-principles">
<h4>UVVM VIP randomization principles<a class="headerlink" href="#uvvm-vip-randomization-principles" title="Permalink to this headline">¶</a></h4>
<p>Randomization may of course be applied with no limitations in a UVVM based testbench. For UVVM VIP however, we recommend the same
general approach as for error injection randomizations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>No randomization of data inside BFMs as this would affect the DUT behaviour or output (and a monitor would be required to
check the actual DUT stimuli). Hence BFM procedures should only be called with explicit data.</p></li>
<li><p>It is recommended that more advanced VVCs include functionality for randomization of data - in order to distribute this
away from the test sequencer and increase the re-use value of a VVC. Thus, a VVC may be told to apply random data, in which
case the VVC will randomly generate data according to a given profile (e.g. uniform) and provide that data to the interface
via the BFM call. The profile and constraints will depend on the needs and the VVC implementation</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="data-randomization-in-bfms">
<h4>Data randomization in BFMs<a class="headerlink" href="#data-randomization-in-bfms" title="Permalink to this headline">¶</a></h4>
<p>There is no data randomization inside a normal BFM, for the reason given above.</p>
</div>
<div class="section" id="data-randomization-in-vvcs">
<h4>Data randomization in VVCs<a class="headerlink" href="#data-randomization-in-vvcs" title="Permalink to this headline">¶</a></h4>
<p>A VVC may be commanded to generate constrained random data, where data in this sense could also be addresses, lengths, etc.
Typically such commands would allow flexibility for the number of accesses and other important aspects - like scoreboards, common
buffers, files, etc. A few randomization profiles have been predefined both as typical use cases and as examples for future
extensions, when needed. The profile names are defined in the type <strong>t_randomisation</strong>, which is declared in the adaptations_pkg.vhd
to allow users to add more profiles.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>NA</p></td>
<td><p>Not applicable (To be used in a record where the field is present, but no randomization wanted)</p></td>
</tr>
<tr class="row-even"><td><p>RANDOM</p></td>
<td><p>Uniform distribution</p></td>
</tr>
<tr class="row-odd"><td><p>RANDOM_FAVOUR_EDGES</p></td>
<td><div class="line-block">
<div class="line">Significantly more edge cases, where “edge” differs between various interfaces.</div>
<div class="line">E.g. UART: Cover patterns like 01111111, 00000000, 11111111, 11111110, 01010101, 10101010.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>&lt;user-defined&gt;</p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vvc-command-syntax">
<h4>VVC Command Syntax<a class="headerlink" href="#vvc-command-syntax" title="Permalink to this headline">¶</a></h4>
<p>See <a class="reference internal" href="#vvc-framework-vvc-parameters-and-sequence"><span class="std std-ref">VVC Parameters and Sequence for Randomization, Sources and Destinations</span></a> for parameter sequence and options.</p>
</div>
</div>
<div class="section" id="testbench-data-routing">
<h3>Testbench Data Routing<a class="headerlink" href="#testbench-data-routing" title="Permalink to this headline">¶</a></h3>
<p>Transaction Info is providing a mechanism for passively routing source data (data entered into the DUT) out of the VVCs to other
parts of the testbench. This data routing is passive in the sense that the transaction data is just provided as a shared variable
- for anyone to read. This is covered in <a class="reference internal" href="#vvc-framework-transaction-info"><span class="std std-ref">Distribution of Transaction Info - From VVCs and/or Monitors</span></a>. There is however also a need for routing data
actively inside the testbench, where routing means fetching from or sending to predefined sources and destinations.</p>
<div class="section" id="to-from-buffer">
<h4>To/from Buffer<a class="headerlink" href="#to-from-buffer" title="Permalink to this headline">¶</a></h4>
<p>UVVM has a global buffer that is divided into multiple smaller buffers that may be indexed and accessed from anywhere in the
testbench. This functionality is described in <a class="reference internal" href="fifo_collection.html#uvvm-fifo-collection"><span class="std std-ref">UVVM FIFO Collection</span></a>. VVC commands requesting sourcing data from or sending
data to these buffers use parameter TO_BUFFER or FROM_BUFFER, followed by the buffer index.</p>
</div>
<div class="section" id="to-scoreboard">
<h4>To Scoreboard<a class="headerlink" href="#to-scoreboard" title="Permalink to this headline">¶</a></h4>
<p>Scoreboards may be used anywhere inside the testbench, but for UVVM the following is recommended:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Use Scoreboards only on the destination side of the testbench, i.e. where data is received or fetched out of the DUT.
E.g. for a UART on the DUT UART TX side (= UART_VVC RX side).</p></li>
<li><p>Every VVC may be connected to one single Scoreboard.</p></li>
<li><p>The Scoreboard instance number should be the same as the VVC instance number.</p></li>
<li><p>When using VVCs, make sure the VVC passes the received data to its Scoreboard, do not check the data in the VVC. E.g. for a
UART_VVC, use the receive-command (and not the expect-command) to forward received data to the Scoreboard.</p></li>
</ol>
</div></blockquote>
<p>VVC commands requesting sending data to the Scoreboard use parameter TO_SB.</p>
</div>
<div class="section" id="data-routing-options">
<h4>Data routing options<a class="headerlink" href="#data-routing-options" title="Permalink to this headline">¶</a></h4>
<p>The profile names are defined in the type <a class="reference internal" href="types_pkg.html#t-data-routing"><span class="std std-ref">t_data_routing</span></a>, which is defined in types_pkg.vhd</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>NA</p></td>
<td><p>Not applicable (To be used in a record where the field is present, but no data routing wanted)</p></td>
</tr>
<tr class="row-even"><td><p>TO_SB</p></td>
<td><p>Data is passed on to the Scoreboard for the given VVC</p></td>
</tr>
<tr class="row-odd"><td><p>FROM_BUFFER</p></td>
<td><p>Data is sourced from the UVVM global buffer</p></td>
</tr>
<tr class="row-even"><td><p>TO_BUFFER</p></td>
<td><p>Data is also sent to the UVVM global buffer</p></td>
</tr>
<tr class="row-odd"><td><p>TO_FILE</p></td>
<td><p>TBD – Not yet implemented (Do not use – as this may change)</p></td>
</tr>
<tr class="row-even"><td><p>FROM_FILE</p></td>
<td><p>TBD – Not yet implemented (Do not use – as this may change)</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;user-defined&gt;</p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h4>VVC Command Syntax<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>See <a class="reference internal" href="#vvc-framework-vvc-parameters-and-sequence"><span class="std std-ref">VVC Parameters and Sequence for Randomization, Sources and Destinations</span></a> for parameter sequence and options.</p>
</div>
</div>
<div class="section" id="controlling-property-checkers">
<h3>Controlling Property Checkers<a class="headerlink" href="#controlling-property-checkers" title="Permalink to this headline">¶</a></h3>
<p>A major VVC advantage is that lots of very useful additional functionality may be added inside the VVC entity, meaning that all
the verification support for a given interface can be encapsulated inside a single VHDL entity. A major advantage of UVVM is that
adding additional functionality and controlling it from the test sequencers is really simple.</p>
<p>One very useful additional functionality is property checkers, and some typical examples of this could be to check the minimum
allowed bit period, the minimum inter-packet gap, back-to-back restrictions, etc., or in general to check a given requirement
continuously - especially when this is easier to do outside the BFM - for instance in a dedicated checker process.</p>
<p>A dedicated checker process would typically just wait for a trigger condition on the interface (like a UART data bit changing its
level), then wait again for a next trigger (the next data bit), and then check that the time between the two changes is not less
than the minimum allowed bit period. This check could then be repeated forever. It is however recommended that the check could be
turned on and off for more flexibility.</p>
<div class="section" id="property-check-configuration">
<h4>Property check configuration<a class="headerlink" href="#property-check-configuration" title="Permalink to this headline">¶</a></h4>
<p>In UVVM, turning checkers on and off is controlled by the VVC configuration (see <a class="reference internal" href="#vvc-framework-status-config-transaction-info"><span class="std std-ref">VVC Status, Configuration and Transaction Information</span></a>),
and often additional control of the checker behaviour is also required. Thus, it is recommended to include the checker control for
each individual check in a dedicated sub-record. An example on this (for the UART VVC) is shown below. See <a class="reference internal" href="vip_uart.html#vip-uart-vvc"><span class="std std-ref">UART VVC</span></a> for implementation.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">bit_rate_checker</span>              <span class="c1">-- Sub-record containing all control of the property checker behaviour</span>
    <span class="p">.</span><span class="n">enable</span>      <span class="kt">boolean</span>       <span class="c1">-- Enables or disables the complete bit rate checker</span>
    <span class="p">.</span><span class="n">min_period</span>  <span class="kt">time</span>
    <span class="p">.</span><span class="n">alert_level</span> <span class="n">t_alert_level</span>
</pre></div>
</div>
<p>For this example, the bit rate checker inside the UART_VVC RX will trigger on changes on the DUT TX and execute the check if
enable is TRUE.</p>
</div>
<div class="section" id="setting-up-the-configuration">
<h4>Setting up the configuration<a class="headerlink" href="#setting-up-the-configuration" title="Permalink to this headline">¶</a></h4>
<p>The bit rate checker configuration may be changed directly from the sequencer via the shared variable VVC configuration.</p>
</div>
</div>
<div class="section" id="vvc-parameters-and-sequence-for-randomization-sources-and-destinations">
<span id="vvc-framework-vvc-parameters-and-sequence"></span><h3>VVC Parameters and Sequence for Randomization, Sources and Destinations<a class="headerlink" href="#vvc-parameters-and-sequence-for-randomization-sources-and-destinations" title="Permalink to this headline">¶</a></h3>
<p>In order to assure a common syntax and understanding for the various VVC commands controlling these features, the sequence and
type of parameters have been defined as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 15%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter sequence</p></th>
<th class="head"><p>Preceding command part</p></th>
<th class="head"><p>[Repetitions]</p></th>
<th class="head"><p>Randomness</p></th>
<th class="head"><p>Data routing type</p></th>
<th class="head"><p>[Data routing index]</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Example A</p></td>
<td><p>uart_transmit(UART_VVCT,1,TX)</p></td>
<td><p>4</p></td>
<td><p>RANDOM_FAVOUR_EDGES</p></td>
<td><p>TO_BUFFER</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>Example B</p></td>
<td><p>uart_receive(UART_VVCT,1,RX)</p></td>
<td></td>
<td></td>
<td><p>TO_SB</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example A means: make 4 transactions with random data (using predefined profile RANDOM_FAVOUR_EDGES) and send the data also to
BUFFER 5, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">uart_transmit</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">TX</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">RANDOM_FAVOUR_EDGES</span><span class="p">,</span> <span class="n">TO_BUFFER</span><span class="p">,</span> <span class="n">C_UART_BUFFER</span><span class="p">,</span> <span class="s">&quot;my message&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Example B means: keep on receiving data and send the received data also to the local Scoreboard, e.g.</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">uart_receive</span><span class="p">(</span><span class="n">UART_VVCT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">RX</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">TO_SB</span><span class="p">,</span> <span class="s">&quot;my message&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Exactly what variants will be available for each VVC is up to the VVC designer, but this gives the sequence and the options.</p>
</div>
<div class="section" id="multiple-central-sequencers">
<h3>Multiple Central Sequencers<a class="headerlink" href="#multiple-central-sequencers" title="Permalink to this headline">¶</a></h3>
<p>A structured test environment is important, and we recommend the use of a structured test harness to instantiate VVCs, DUT, clock
generator and so forth. The testbench may consist of one or more test sequencers which are used to control the complete testbench
architecture with any number of VVCs, although for a better testbench overview we recommend having a single central test sequencer
only - for most testbenches.</p>
</div>
<div class="section" id="monitors">
<h3>Monitors<a class="headerlink" href="#monitors" title="Permalink to this headline">¶</a></h3>
<p>Monitors could be great to check the interface accesses to a DUT - to report the transaction to the testbench - with all relevant
info like operation (write, read, transmit, …), data, address, etc. This information may be critical in order to understand the
operation of the DUT and its expected outputs. A monitor is not a protocol checker, but may of course check various properties of
an interface/protocol. A typical Monitor will however only provide the relevant basic information and leave more advance
interpretation to other parts of a testbench. For simple protocols like the UART, UVVM also includes basic error checking in the
Monitor - as this happens at a very low level. For more advanced protocols it would make sense to just pass on the low level info
to a higher level checker. The reason for making a dedicated monitor rather than leaving that to the testbench model is to achieve
a better testbench structure and more efficient reuse.</p>
<p>It should however be mentioned that implementing Transaction Info (see <a class="reference internal" href="#vvc-framework-transaction-info"><span class="std std-ref">Distribution of Transaction Info - From VVCs and/or Monitors</span></a>) inside a VVC
significantly reduces the need for a dedicated monitor, as the VVC will then be able to pass the complete transaction information
on to, for instance, a model inside the Testbench.</p>
<div class="section" id="transfer-of-monitor-information-to-the-testbench">
<h4>Transfer of Monitor information to the testbench<a class="headerlink" href="#transfer-of-monitor-information-to-the-testbench" title="Permalink to this headline">¶</a></h4>
<p>The mechanism for passing the monitor deduced transaction out of the monitor is almost exactly the same as for passing transaction
info out of a VVC - as described in <a class="reference internal" href="#vvc-framework-transaction-info"><span class="std std-ref">Distribution of Transaction Info - From VVCs and/or Monitors</span></a>. The only difference is that the monitor can only
provide parts of what the VVC can provide.</p>
<blockquote>
<div><ul class="simple">
<li><p>No monitor can provide info about compound transactions.</p></li>
<li><p>For a split transaction protocol like Avalon - only the sub-transactions could be provided (which could be analysed at the
higher level to provide Base transactions).</p></li>
<li><p>A monitor cannot provide meta data like command index or command message.</p></li>
</ul>
</div></blockquote>
<p>As the monitor does not know what to expect at the beginning of a transaction the following field limitations apply:</p>
<blockquote>
<div><ul>
<li><p>Operation: Can only be known some time after the start of the transaction. Will be set when the type of the transaction is
known, e.g. TRANSMIT or RECEIVE for UART (otherwise NO_OPERATION).</p></li>
<li><div class="line-block">
<div class="line">Transaction_status: Will be set to FAILED or SUCCEEDED as soon as the result is 100% given. Prior to that - during the
transaction: IN_PROGRESS.</div>
<div class="line">FAILED/SUCCEEDED will remain for the transaction_display_time given inside the monitor configuration record, or until the
next transaction FAILED or SUCCEEDED.</div>
</div>
</li>
</ul>
</div></blockquote>
<p>An example of a complete monitor is shown in the UART VIP directory.</p>
</div>
<div class="section" id="transaction-info-transfer-signals">
<h4>Transaction info transfer signals<a class="headerlink" href="#transaction-info-transfer-signals" title="Permalink to this headline">¶</a></h4>
<p>The Transaction info provided out of a Monitor uses a set of a global signal and a shared variable. These and all related VHDL
types are defined in transaction_pkg.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Monitor trigger signal</strong> : <em>global_&lt;protocol-name&gt;_monitor_transaction_trigger</em>, e.g. global_uart_monitor_transaction_trigger(channel, instance number)</p></li>
<li><p><strong>Monitor shared variable</strong> : <em>shared_&lt;protocol-name&gt;_monitor_transaction_info</em>, e.g. shared_uart_monitor_transaction_info(channel, instance number)</p></li>
</ul>
</div></blockquote>
<p>See <a class="reference internal" href="#vvc-framework-transaction-info-record"><span class="std std-ref">Transaction Info record signals</span></a> Table 5 for more details.</p>
</div>
</div>
<div class="section" id="compile-scripts">
<span id="vvc-framework-compile-scripts"></span><h3>Compile Scripts<a class="headerlink" href="#compile-scripts" title="Permalink to this headline">¶</a></h3>
<p>In the script folder in the root directory the <em>compile_all.do</em> compiles all UVVM components. This script may be called with one
to three input arguments:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first input argument is the directory of the script folder at the root directory from the working directory.</p></li>
<li><p>The second input argument is the target directory of the compiled libraries, by default every library is compiled in a sim
folder in the corresponding components directory.</p></li>
<li><p>The third input argument is the directory to a custom component list in .txt format. The script will only compile the
components listed in that file. By default, the script uses the file component_list.txt located in uvvm/script. This file
can be modified so that only some components are compiled.</p></li>
</ul>
</div></blockquote>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Example: do uvvm/script/compile_all.do uvvm/script</span>
</pre></div>
</div>
<p>There are also compile scripts for all UVVM components located in the script folder of each UVVM component. These scripts can be
called with two input arguments:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first input argument is the directory of the component folder from the working directory.</p></li>
<li><p>The second input argument is the target directory of the compiled library, default is the sim folder in the respective
component.</p></li>
</ul>
</div></blockquote>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Example: do uvvm/uvvm_vvc_framework/script/compile_src.do uvvm/uvvm_vvc_framework</span>
</pre></div>
</div>
</div>
<div class="section" id="scope-of-verbosity-control">
<span id="vvc-framework-verbosity-ctrl"></span><h3>Scope of Verbosity Control<a class="headerlink" href="#scope-of-verbosity-control" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">Message IDs are used for verbosity control in many of the procedures and functions in UVVM, as well as log messages and checks
in VVCs, BFMs and Scoreboards.</div>
<div class="line">Note that VVCs and Scoreboards come with dedicated message ID panels and are not affected by the global message ID panel, but
accessed by addressing the targeting VVC or Scoreboard and, if applicable, instance number or with a broadcast.</div>
<div class="line">Also note that when a VVC is executing commands triggered by an HVVC (Hierarchical-VVC), e.g. SBI write due to Ethernet transmit,
the VVC will use the HVVC’s message ID panel instead. See <a class="reference internal" href="#vvc-frameworks-hierarchical-vvcs"><span class="std std-ref">Hierarchical VVCs</span></a> for an example of the HVVC
structure.</div>
</div>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Global message ID panel. Does not apply to VVCs or Scoreboards, as they have their own local message ID panel</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">ALL_MESSAGES</span><span class="p">);</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">ID_SEQUENCER</span><span class="p">);</span>

<span class="c1">-- VVC message ID panel</span>
<span class="n">disable_log_msg</span><span class="p">(</span><span class="n">VVC_BROADCAST</span><span class="p">,</span> <span class="n">ALL_MESSAGES</span><span class="p">);</span>            <span class="c1">-- broadcast to all VVCs and instances</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">I2C_VVCT</span><span class="p">,</span> <span class="n">C_VVC_INSTANCE_1</span><span class="p">,</span> <span class="n">ID_BFM_WAIT</span><span class="p">);</span> <span class="c1">-- I2C VVC instance 1</span>
<span class="n">enable_log_msg</span><span class="p">(</span><span class="n">I2C_VVTC</span><span class="p">,</span> <span class="n">C_VVC_INSTANCE_2</span><span class="p">,</span> <span class="n">ID_BFM_WAIT</span><span class="p">);</span> <span class="c1">-- I2C VVC instance 2</span>

<span class="c1">-- Scoreboard message ID panel</span>
<span class="k">shared</span> <span class="k">variable</span> <span class="n">sb_under_test</span> <span class="o">:</span> <span class="n">record_sb_pkg</span><span class="p">.</span><span class="n">t_generic_sb</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">sb_under_test</span><span class="p">.</span><span class="n">disable_log_msg</span><span class="p">(</span><span class="n">ALL_INSTANCES</span><span class="p">,</span> <span class="n">ID_CTRL</span><span class="p">);</span>  <span class="c1">-- broadcast to all SB instances</span>
<span class="n">sb_under_test</span><span class="p">.</span><span class="n">enable_log_msg</span><span class="p">(</span><span class="n">C_SB_INSTANCE_1</span><span class="p">,</span> <span class="n">ID_DATA</span><span class="p">);</span> <span class="c1">-- SB instance 1</span>
</pre></div>
</div>
<p>The predefined message IDs are listed in <a class="reference internal" href="utility_library.html#message-ids"><span class="std std-ref">Message IDs</span></a>.</p>
</div>
<div class="section" id="hierarchical-vvcs">
<span id="vvc-frameworks-hierarchical-vvcs"></span><h3>Hierarchical VVCs<a class="headerlink" href="#hierarchical-vvcs" title="Permalink to this headline">¶</a></h3>
<p>Many protocols and applications consist of several abstraction levels, e.g. physical layer, link layer, transaction layer, etc.
When writing a test case for a higher level you most likely want to ignore the underlying levels and only deal with the scope of
the relevant level. The test case will be less complex and easier to both write and read. A hierarchical VVC (HVVC) is a VVC of a
higher protocol level than the physical layer, i.e. it has no physical connections. The test case only communicates with the HVVC
which communicate with the lower level. Data is propagated upwards and downwards between the HVVC and DUT through a standard VVC
connected to the DUT.</p>
<p>The HVVC-to-VVC Bridge is the connection between a hierarchical VVC (HVVC) and the VVC at a lower protocol level, in this context
referred to only as the VVC. Communications between the HVVC and VVC is handled by the HVVC-to-VVC Bridge. Data is transferred
between the HVVC and HVVC-to-VVC Bridge on a common interface and converted in the HVVC-to-VVC Bridge to/from the specific
interface of the VVC used. An example of this concept used on Ethernet is seen in Figure 8.</p>
<div class="figure align-center" id="id21">
<a class="reference internal image-reference" href="_images/hvvc_to_vvc_bridge.png"><img alt="HVVC-to-VVC Bridge" src="_images/hvvc_to_vvc_bridge.png" style="width: 550pt;" /></a>
<p class="caption"><span class="caption-text">Figure 8 Example of HVVC-to-VVC Bridge implemented in an Ethernet HVVC</span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="hvvc-usage">
<h4>HVVC usage<a class="headerlink" href="#hvvc-usage" title="Permalink to this headline">¶</a></h4>
<p>To simulate an HVVC you only need to do the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Instantiate the HVVC in the test harness and set the generic GC_PHY_INTERFACE to the physical interface you want to use.</p></li>
<li><p>Instantiate the VVC of the physical interface with the same instance index as GC_PHY_VVC_INSTANCE_IDX.</p></li>
<li><p>Connect the VVC of the physical interface to the DUT.</p></li>
</ol>
</div></blockquote>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">i1_ethernet_vvc</span> <span class="o">:</span> <span class="k">entity</span> <span class="nc">bitvis_vip_ethernet</span><span class="p">.</span><span class="n">ethernet_vvc</span>
  <span class="k">generic</span> <span class="k">map</span><span class="p">(</span>
    <span class="n">GC_INSTANCE_IDX</span>         <span class="o">=&gt;</span> <span class="n">C_VVC_ETH</span><span class="p">,</span>
    <span class="n">GC_PHY_INTERFACE</span>        <span class="o">=&gt;</span> <span class="n">GMII</span><span class="p">,</span>
    <span class="n">GC_PHY_VVC_INSTANCE_IDX</span> <span class="o">=&gt;</span> <span class="n">C_VVC_GMII</span>
<span class="p">);</span>

<span class="n">i1_gmii_vvc</span> <span class="o">:</span> <span class="k">entity</span> <span class="nc">bitvis_vip_gmii</span><span class="p">.</span><span class="n">gmii_vvc</span>
  <span class="k">generic</span> <span class="k">map</span> <span class="p">(</span>
    <span class="n">GC_INSTANCE_IDX</span>  <span class="o">=&gt;</span> <span class="n">C_VVC_GMII</span>
  <span class="p">)</span>
  <span class="k">port</span> <span class="k">map</span> <span class="p">(</span>
    <span class="n">gmii_vvc_tx_if</span> <span class="o">=&gt;</span> <span class="n">gmii_vvc_tx_if</span><span class="p">,</span>
    <span class="n">gmii_vvc_rx_if</span> <span class="o">=&gt;</span> <span class="n">gmii_vvc_rx_if</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Any VVC can be used as a physical interface, however it needs to have an HVVC-to-VVC Bridge implementation. You can find the
available implementations under <em>bitvis_vip_hvvc_to_vvc_bridge/src</em>.</p>
<p>For information on how to implement your own, see <a class="reference internal" href="vip_hvvc_to_vvc_bridge.html#vip-hvvc-to-vvc-bridge"><span class="std std-ref">Bitvis VIP HVVC-to-VVC Bridge</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="vvc-implementation-guide">
<h2>VVC Implementation Guide<a class="headerlink" href="#vvc-implementation-guide" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul class="simple">
<li><p>This guide is meant for users that want to make their own VVC.</p></li>
<li><p>Users that only write test cases that are using the VVCs do <strong>NOT</strong> need to read this guide.</p></li>
</ul>
</div>
<p>Making test cases using available VVCs is very easy. Implementing new VVCs is slightly more complex, but fast, safe and efficient
once you understand the VVC mechanisms.</p>
<ul class="simple">
<li><p>This guide goes through all relevant files needed to make a complete VVC.</p></li>
<li><p>The intention is to allow a VVC implementer to go through file by file and understand and modify as needed.</p></li>
<li><p>All code objects and functionality given in the VVC and UVVM files are considered mandatory unless otherwise noted.</p></li>
</ul>
<div class="section" id="prerequisites">
<h3>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ol class="arabic simple">
<li><p>Go through <a class="reference external" href="https://github.com/UVVM/UVVM/tree/master/uvvm_vvc_framework/doc/The_critically_missing_VHDL_TB_feature.ppsx">The critically missing VHDL testbench feature - Finally a structured approach - A brief introduction</a> - for a
presentation on cycle related corner cases and the need for a far more structured verification approach, and to understand
the basic concepts, the communication and handshake between the central sequencer and the VVCs.</p></li>
<li><p>If your VVC is going to access a DUT interface, you need to have a BFM (Bus Functional Model) for that interface -
independent of whether you are going to make a VVC.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="implementing-your-new-vvc">
<h3>Implementing your new VVC<a class="headerlink" href="#implementing-your-new-vvc" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ol class="arabic simple">
<li><p>Use the script vvc_generator located in the <em>uvvm_vvc_framework/script/vvc_generator/</em> to generate a new VVC. Notice that
the name length is limited by C_LOG_SCOPE_WIDTH (default =20) in <em>uvvm_util/src/adaptations_pkg.vhd</em></p></li>
<li><p>Then see comments in the code for where to make required changes.</p></li>
<li><p>If the new VVC uses multiple channels other than TX and RX, modify the t_channel type under <em>uvvm_util/src/adaptations_pkg.vhd</em></p></li>
<li><p>See this guide for an explanation to all the various sections you need to evaluate or modify - file by file.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="dependent-and-independent-source">
<h3>Dependent and independent source<a class="headerlink" href="#dependent-and-independent-source" title="Permalink to this headline">¶</a></h3>
<p>One of the key concepts of the UVVM VVC Framework is the compilation strategy, and how some packages in the UVVM VVC Framework
directory are compiled into each of the individual VVC libraries. To avoid confusion about this for future VVC designers, the VVC
dependent and VVC independent sources have been marked and split into two source directories:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The target dependent source, also known as packages that are compiled into each of the individual VVCs, are placed in the
<em>src_target_dependent/</em> folder. These files are also prefixed with “td_*” for “target dependent”.</p></li>
<li><p>The target independent files are compiled into the uvvm_vvc_framework library. These files are placed in the <em>src/</em> folder
and prefixed with “ti_*” for “target independent”.</p></li>
</ol>
</div></blockquote>
<p>For examples of how the compile order should be handled, please see the example VIPs’ documentation and compile scripts.</p>
</div>
<div class="section" id="name-vvc-vhd">
<span id="vvc-framework-name-vvc"></span><h3>&lt;name&gt;_vvc.vhd<a class="headerlink" href="#name-vvc-vhd" title="Permalink to this headline">¶</a></h3>
<div class="section" id="for-single-channel-vvcs">
<h4>For single channel VVCs<a class="headerlink" href="#for-single-channel-vvcs" title="Permalink to this headline">¶</a></h4>
<div class="section" id="entity">
<h5>Entity<a class="headerlink" href="#entity" title="Permalink to this headline">¶</a></h5>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>GC_INSTANCE_IDX</p></td>
<td><p>Needed in case there are multiple instances of a given VVC. (E.g. DUT with 2 &lt;VVC-NAME&gt;S). Default is 1, but any
natural type is ok.</p></td>
</tr>
<tr class="row-even"><td><p>GC_&lt;name&gt;_CONFIG</p></td>
<td><p>Recommended. Allows predefined BFM behaviour to be set up for every VVC.</p></td>
</tr>
<tr class="row-odd"><td><p>GC_CMD_QUEUE_*</p></td>
<td><p>Needed to limit the queue size and to generate a warning if more elements in the queue than ever expected.</p></td>
</tr>
<tr class="row-even"><td><p>Other generics</p></td>
<td><p>Optional and VVC dependent. These generics could for example contain widths of BFM signals.</p></td>
</tr>
</tbody>
</table>
<p>The interface to the DUT and any other needed I/O. The examples show DUT interfaces as single signals, records and records of
records. This is optional.</p>
</div>
<div class="section" id="declarations">
<h5>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h5>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>C_SCOPE</p></td>
<td><p>Used for logs and alerts. C_VVC_NAME is defined in the VVC <cite>vvc_methods_pkg.vhd</cite></p></td>
</tr>
<tr class="row-even"><td><p>C_VVC_LABELS</p></td>
<td><p>A record of constants, e.g. name and channel, used in multiple procedures.</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Various status signals used as flags between the processes.</p></li>
<li><p>Command termination record. (Fields: set, reset, is_active). Where set and reset signal fields are used to toggle is_active.
Used as inter process flags.</p></li>
<li><p>command_queue is the queue of commands to be executed in sequence towards the DUT.</p></li>
<li><p>The aliases are defined to allow common and simplified names.</p></li>
</ul>
</div>
<div class="section" id="constructor">
<h5>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h5>
<p>The constructor is run once only - immediately when starting the simulation. The procedure:</p>
<blockquote>
<div><ul class="simple">
<li><p>Initialises VVC with BFM config and the queue with queue name.</p></li>
<li><p>Allows constructor log for VVC info (using ID_CONSTRUCTOR), and VVC Queue info (using ID_CONSTRUCTOR_SUB).</p></li>
</ul>
</div></blockquote>
<p>The procedure will report alerts with severity TB_FAILURE if one of the following occurs:</p>
<blockquote>
<div><ul class="simple">
<li><p>The instantiated VVC index is higher or equal to the maximum allowed number of VVC instances, given by C_MAX_VVC_INSTANCE_NUM
in <em>uvvm_util/src/adaptations_pkg.vhd</em></p></li>
<li><p>UVVM has not been initialized.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="command-interpreter">
<h5>Command Interpreter<a class="headerlink" href="#command-interpreter" title="Permalink to this headline">¶</a></h5>
<p>Waits for commands from the central test sequencer distributed to this VVC, then puts the command on the queue for execution or
immediately performs the required action - depending on command type. Afterwards, it acknowledges the command and waits for the
next command from the sequencer.</p>
<div class="line-block">
<div class="line">Step 0</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">initialize_interpreter()</span></code></div>
<div class="line-block">
<div class="line">- Initialises parameters to default passive/initial values (e.g. terminate_current_cmd.set := ‘0’).</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 1</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">await_cmd_from_sequencer()</span></code></div>
<div class="line-block">
<div class="line">- Waits for a command from the central sequencer. Continues on matching VVC, instance index, name and channel.</div>
<div class="line">- Log at start using ID_CMD_INTERPRETER_WAIT and at the end using ID_CMD_INTERPRETER.</div>
<div class="line">- Will only accept exact matches of instance index and name, and either the correct address or “ALL_CHANNELS”.</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 2a (Only if command type is QUEUED)</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">put_command_on_queue()</span></code></div>
<div class="line-block">
<div class="line">- Puts the received command on the VVC queue (for later retrieval by the Command Executor).</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 2b (Only if command type is IMMEDIATE)</div>
<div class="line">Execute the requested command/operation.</div>
<div class="line-block">
<div class="line">- For the VVC methods these procedures will correspond to the UVVM methods, but prepended with “interpreter_”, e.g.
“interpreter_await_completion()”. These UVVM methods are documented in <a class="reference internal" href="#vvc-framework-methods"><span class="std std-ref">Common VVC Methods</span></a>. Other commands are
documented in their respective VIPs.</div>
<div class="line">- format_commmand_idx(): (ti_vvc_framework_support_pkg) Converts the command index to string, enclosed by C_CMD_IDX_PREFIX and
C_CMD_IDX_SUFFIX (found in <em>uvvm_util/src/adaptations_pkg.vhd</em>).</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 3</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">acknowledge_cmd()</span></code></div>
<div class="line-block">
<div class="line">- Acknowledges the command from the sequencer by driving the <em>global_vvc_ack</em> signal to ‘1’ for 1 delta cycle, then setting it
back to ‘Z’. This lets the central sequencer know that it can continue execution.</div>
</div>
</div>
</div>
<div class="section" id="command-executor">
<h5>Command Executor<a class="headerlink" href="#command-executor" title="Permalink to this headline">¶</a></h5>
<p>Fetches commands from the command queue - if any. Then executes the command and fetches or waits for the next command in the
command queue.</p>
<div class="line-block">
<div class="line">Step 0</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">initialize_executor()</span></code></div>
<div class="line-block">
<div class="line">- Initialises parameters to default passive/initial values (e.g. terminate_current_cmd.reset := ‘0’).</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 1</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">fetch_command_and_prepare_executor()</span></code></div>
<div class="line-block">
<div class="line">- Fetches a command from the queue (waits until available if needed).</div>
<div class="line">- Sets relevant flag parameters.</div>
<div class="line">- Log command using ID_CMD_EXECUTOR (or log using ID_CMD_EXECUTOR_WAIT if queue is empty).</div>
</div>
<div class="line">Set transaction information for wave-view.</div>
<div class="line-block">
<div class="line">- <em>transaction_info_for_waveview</em> (from vvc_methods_pkg.vhd) is a shared variable intended for use in a wave-view - to yield a
better overview of transaction info. Setting this information is optional. The pad_string() and to_string() procedures are
documented in <a class="reference internal" href="utility_library.html#util-string-handling"><span class="std std-ref">String handling</span></a>.</div>
</div>
<div class="line">Insert inter-BFM delay if requested.</div>
<div class="line-block">
<div class="line">- <code class="docutils literal notranslate"><span class="pre">insert_inter_bfm_delay_if_requested()</span></code> Inserts either start-to-start or finish-to-start delay between BFM accesses if
this is set in the <em>inter_bfm_delay</em> parameter in ‘vvc_config’. Logs information using ID_CMD_EXECUTOR.</div>
<div class="line">- If the command currently being processed by the executor is a BFM access, a timestamp will be stored in
<em>v_timestamp_start_of_current_bfm_access</em>.</div>
</div>
</div>
<div class="line-block">
<div class="line">Step 2</div>
<div class="line">Executes a command depending on the requested command/operation.</div>
<div class="line-block">
<div class="line">- <em>terminate_current_cmd</em> is only checked inside operations that require multiple BFM accesses - like for instance a POLL_UNTIL
command.</div>
<div class="line">- <code class="docutils literal notranslate"><span class="pre">store_result()</span></code> is executed for any BFM, where it makes sense for you to store the result of a BFM access. In our example
for SBI we think it only makes sense for ‘READ’.</div>
<div class="line">- Logging as defined by your BFM.</div>
<div class="line">- Transaction info can be stored in the <em>transaction_info_for_waveview</em> struct for each command type, but this is optional.</div>
</div>
<div class="line">Update the BFM access timestamps if this was a BFM access.</div>
<div class="line-block">
<div class="line">- <em>v_timestamp_of_last_bfm_access</em> is set to ‘now’.</div>
<div class="line">- <em>v_timestamp_start_of_last_bfm_access</em> is set to <em>v_timestamp_start_of_current_bfm_access</em>.</div>
</div>
<div class="line">The <em>terminate_current_cmd</em> flag is reset if it has been active.</div>
<div class="line">Update the <em>last_cmd_idx_executed</em> variable with the current command index (<em>v_cmd.cmd_idx</em>).</div>
</div>
</div>
<div class="section" id="command-terminator">
<h5>Command Terminator<a class="headerlink" href="#command-terminator" title="Permalink to this headline">¶</a></h5>
<p>The command terminator concurrent procedure sets the <em>is_active</em> flag based on the set and reset flags.</p>
</div>
</div>
<div class="section" id="additional-for-multi-channel-vvcs">
<h4>Additional for multi-channel VVCs<a class="headerlink" href="#additional-for-multi-channel-vvcs" title="Permalink to this headline">¶</a></h4>
<p>Please note that we strongly recommend implementing the VVCs such that each leaf VVC handles one independent DUT communication
thread (here: ‘channel’). No more; no less. This allows a single command queue and a single executor handling DUT communication.
(Additional processes to handle other characteristics is fine. E.g., a parallel bit-rate check thread).</p>
<p>Note that SBI_VVC must handle both read and write accesses, but never simultaneously and always in the given order.</p>
<p>Multi-channel VVCs may be implemented in many different ways - depending on your preferences and priorities. Some examples:</p>
<blockquote>
<div><ol class="arabic">
<li><div class="line-block">
<div class="line"><strong>As unique VVC implementation</strong></div>
<div class="line">Unique VVCs may be used in order to omit the channel input, e.g. UART RX VVC and UART TX VVC. UART TX VVC would only
contain TX specific BFM procedures, while UART RX VVC would only contain RX specific BFM procedures. With this approach
the testbench sequencer calls would look like e.g. (assuming both VVCs in this pair are set to instance index 1):</div>
<div class="line-block">
<div class="line">a. uart_transmit(UART_TX_VVCT, 1, …)</div>
<div class="line">b. uart_receive(UART_RX_VVCT, 1, …)</div>
</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>As shared VVC implementation with usage restricted by user, and multiple VVC instances</strong></div>
<div class="line">A combined VVC with different VVC instances for different channels e.g. RX and TX. The TX instance could e.g. be instance
1, and the RX instance could be e.g. instance 2. Using this UART VVC with this implementation would look like:</div>
<div class="line-block">
<div class="line">a. uart_transmit(UART_VVCT, 1, …)</div>
<div class="line">b. uart_receive(UART_VVCT, 2, …)</div>
</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>As shared VVC implementation with GC_CHANNEL generic input</strong></div>
<div class="line">A combined VVC with the same combined VVC implementation, but separate instances for different channels e.g. RX and TX
(both functionalities inside the same leaf VVC). The downside of this implementation is that it would be possible to call
TX BFM procedures when calling the RX VVC channel. Using this UART VVC would look like:</div>
<div class="line-block">
<div class="line">a. uart_transmit(UART_VVCT, TX, 1, …)</div>
<div class="line">b. uart_receive(UART_VVCT, RX, 1, …)</div>
</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>As unique VVC implementation with GC_CHANNEL generic input</strong></div>
<div class="line">This approach uses unique VVC implementations for each channel, e.g. in uart_rx_vvc.vhd and uart_tx_vvc.vhd, but they
both share the VVC target parameter, UART_VVCT. They both use the GC_CHANNEL generic input to specify their channel, i.e.
TX or RX. This is similar to the method described in example 3, but with restrictions that ensure that e.g. the UART TX
VVC can’t use the UART RX BFM procedures. The included bitvis_vip_uart example is implemented with this method. Using
this UART VVC would look like:</div>
<div class="line-block">
<div class="line">a. uart_transmit(UART_VVCT, TX, 1, …)</div>
<div class="line">b. uart_receive(UART_VVCT, RX, 1, …)</div>
</div>
</div>
</li>
</ol>
</div></blockquote>
<p>When using multiple leaf VVCs it is recommended to use a wrapper architecture to encapsulate the channels. This way, it is
possible to instantiate a single VVC rather than each VVC channel individually. For more information about the wrapper architecture,
see the uart_vvc.vhd example in the bitvis_vip_uart/src/ directory.</p>
</div>
</div>
<div class="section" id="vvc-cmd-pkg-vhd">
<h3>vvc_cmd_pkg.vhd<a class="headerlink" href="#vvc-cmd-pkg-vhd" title="Permalink to this headline">¶</a></h3>
<div class="section" id="t-operation">
<h4>t_operation<a class="headerlink" href="#t-operation" title="Permalink to this headline">¶</a></h4>
<p>Contains all UVVM common operations, e.g. AWAIT_COMPLETION and ENABLE_LOG_MSG, in addition to the VVC specific operations such as
e.g. WRITE and READ. The VVC specific will have to be evaluated and potentially replaced when implementing a new VVC. The
t_operation type is used when relaying commands from the sequencer to the VVC. The t_operation type also has its own to_string()
function in this package.</p>
</div>
<div class="section" id="t-vvc-cmd-record">
<h4>t_vvc_cmd_record<a class="headerlink" href="#t-vvc-cmd-record" title="Permalink to this headline">¶</a></h4>
<p>Record type used for relaying a command from the testbench sequencer to the VVC. The record contains fields needed in the common
UVVM procedures (listed under the “Common UVVM fields” comment), and VVC specific fields needed to relay data to the VVC executor.
The VVC specific data fields should contain any data fields that the BFM procedures might need, e.g. data, address, timeouts etc.
There is also a default for this type called C_VVC_CMD_DEFAULT in this package.</p>
</div>
<div class="section" id="constants">
<h4>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h4>
<p>The vvc_cmd_pkg.vhd should contain constants that needs to be set for the entire VVC. In most VVCs this will include the
C_VVC_CMD_STRING_MAX_LENGTH which determines the maximum size of msg variables in the VVC. It is also a good idea to declare
constants for maximum VVC data/address bus sizes here. It will be possible to construct VVCs with bus sizes up to and including
the sizes declared here.</p>
</div>
<div class="section" id="shared-variables">
<h4>Shared Variables<a class="headerlink" href="#shared-variables" title="Permalink to this headline">¶</a></h4>
<p>The shared_vvc_cmd shared variable (type t_vvc_cmd_record) is used for relaying commands between sequencer methods and the VVC. It
is default set to C_VVC_CMD_DEFAULT, which is also declared in this file.</p>
</div>
</div>
<div class="section" id="vvc-methods-pkg-vhd">
<h3>vvc_methods_pkg.vhd<a class="headerlink" href="#vvc-methods-pkg-vhd" title="Permalink to this headline">¶</a></h3>
<div class="section" id="constants-and-aliases">
<h4>Constants and aliases<a class="headerlink" href="#constants-and-aliases" title="Permalink to this headline">¶</a></h4>
<p>The vvc_methods_pkg contains constants for the VVC name, e.g. “&lt;NAME&gt;_VVC”. There are also aliases created to make the code more
readable.</p>
</div>
<div class="section" id="name-vvct">
<h4>&lt;NAME&gt;_VVCT<a class="headerlink" href="#name-vvct" title="Permalink to this headline">¶</a></h4>
<p>The &lt;NAME&gt;_VVCT signal (e.g. SBI_VVCT) is the VVC target record signal. The target type <strong>t_vvc_target_record</strong> is a record that
contains the parameters needed to trigger a VVC, and to identify the correct target of a VVC command.</p>
</div>
<div class="section" id="t-vvc-config">
<h4>t_vvc_config<a class="headerlink" href="#t-vvc-config" title="Permalink to this headline">¶</a></h4>
<p>This type contains the needed configuration for setting up the VVC and BFM. In Bitvis VVCs the BFM configuration is encapsulated
in a bfm_config record, of type <strong>t_&lt;bfm_name&gt;_bfm_config</strong>. This record is placed in this file and compiled into each VVC since
the VVC/BFM configuration will differ for each VVC. The record contents are:</p>
<blockquote>
<div><ul class="simple">
<li><p>inter_bfm_delay: A record containing the potential inter-bfm delay specifications, e.g. if BFM accesses shall be separated
with a given time.</p></li>
<li><p>cmd_queue_count_*: Command queue specifications.</p></li>
<li><p>msg_id_panel: The ID panel that the VVC shall use.</p></li>
<li><p>bfm_config: A record containing all settings for the BFM, e.g. clock periods, message IDs etc.</p></li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line">A constant C_&lt;name&gt;_VVC_CONFIG_DEFAULT is defined for this type to use as default value.</div>
<div class="line">A shared variable array of t_vvc_config <em>shared_&lt;name&gt;_vvc_config</em> is declared and all elements are set to the default value.</div>
</div>
</div>
<div class="section" id="t-vvc-status">
<h4>t_vvc_status<a class="headerlink" href="#t-vvc-status" title="Permalink to this headline">¶</a></h4>
<p>The optional status record is created in order for the testbench sequencer to have access to the status of the VVC. The status
record can contain anything that is relevant for the outside, and it is recommended to have at least these three fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>current_cmd_idx: The current command index being processed in the executor.</p></li>
<li><p>previous_cmd_idx: The previous command index being processed in the executor.</p></li>
<li><p>pending_cmd_idx: The number of pending commands to be processed by the executor.</p></li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line">A constant C_VVC_STATUS_DEFAULT is defined for this type to use as default value.</div>
<div class="line">A shared variable array of t_vvc_status <em>shared_&lt;name&gt;_vvc_status</em> is declared and all elements are set to the default value.</div>
</div>
</div>
<div class="section" id="t-transaction-info-for-waveview">
<h4>t_transaction_info_for_waveview<a class="headerlink" href="#t-transaction-info-for-waveview" title="Permalink to this headline">¶</a></h4>
<p>The t_transaction_info_for_waveview type is an optional status record to be used in the wave-view. This record should be modified
to suit the BFM fields, but it can also contain the VVC field t_operation, which can be updated with the VVC operation currently
being processed by the executor. The transaction_info_for_waveview is meant as a way of improving the readability of wave-views.</p>
<div class="line-block">
<div class="line">A constant C_TRANSACTION_INFO_FOR_WAVEVIEW_DEFAULT is defined for this type to use as default value.</div>
<div class="line">A shared variable of t_transaction_info_for_waveview <em>t_&lt;name&gt;_transaction_info_for_waveview</em> is declared and all elements are set
to the default value.</div>
</div>
</div>
<div class="section" id="vvc-dedicated-methods">
<h4>VVC Dedicated Methods<a class="headerlink" href="#vvc-dedicated-methods" title="Permalink to this headline">¶</a></h4>
<p>The vvc_methods_pkg.vhd file also contains the VVC procedures that are called from the testbench sequencer. These procedures
should reflect the procedures in the BFM, e.g. &lt;name&gt;_write or &lt;name&gt;_receive. The parameters of these procedures are mostly up to
the user, but it is recommended that the BFM arguments that are rarely altered be placed into the bfm_config parameter, while the
parameters that changes often are used as input arguments.</p>
<p>Since these VVC methods are reused for all instances of this VVC, it is necessary with some extra parameters in order to specify
which VVC instance to forward the call to. This is done with the first two (or three) parameters:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">signal</span>   <span class="n">VVCT</span>             <span class="o">:</span> <span class="k">inout</span> <span class="n">t_vvc_target_record</span><span class="p">;</span>
<span class="k">constant</span> <span class="n">vvc_instance_idx</span> <span class="o">:</span> <span class="k">in</span>    <span class="kt">integer</span><span class="p">;</span>
<span class="k">constant</span> <span class="n">channel</span>          <span class="o">:</span> <span class="k">in</span>    <span class="n">t_channel</span><span class="p">;</span>           <span class="c1">-- Only if the VVC is multi-channel.</span>
</pre></div>
</div>
<p>The method bodies are quite similar for all VVC commands:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>First, the shared_vvc_cmd record is set to its default value, resetting the data from any potential previous command.</p></li>
<li><p>The general VVC fields (e.g. name and instance index) are set using the UVVM method set_general_target_and_command_fields().</p></li>
<li><p>The VVC specific fields are set in the <em>shared_vvc_cmd</em> shared variable. This means e.g. address and data fields.</p></li>
<li><p>The command is sent to all VVCs using the UVVM method send_command_to_vvc(VVCT).</p></li>
</ol>
</div></blockquote>
<p>All VVC instances and channels of this type receive the command, but only the VVC with the correct instance index, channel and
name will accept it and acknowledge it.</p>
</div>
</div>
<div class="section" id="vvc-context-vhd">
<h3>vvc_context.vhd<a class="headerlink" href="#vvc-context-vhd" title="Permalink to this headline">¶</a></h3>
<p>This file contains all the necessary packages that are used when simulating a VVC. When adding a VVC to a testbench, the user only
needs to add the following lines in the header:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">bitvis_vip_</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">context</span> <span class="n">bitvis_vip_</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">.</span><span class="n">vvc_context</span><span class="p">;</span>
</pre></div>
</div>
<p>The generated file from the vvc_generator script has the following as default:</p>
<blockquote>
<div><ul class="simple">
<li><p>transaction_pkg.all</p></li>
<li><p>vvc_methods_pkg.all</p></li>
<li><p>td_vvc_framework_common_methods_pkg.all</p></li>
<li><p>&lt;name&gt;_bfm_pkg.t_&lt;name&gt;_if –&gt; BFM interface type (remove if not used)</p></li>
<li><p>&lt;name&gt;_bfm_pkg.t_&lt;name&gt;_bfm_config –&gt; BFM configuration type</p></li>
<li><p>&lt;name&gt;_bfm_pkg.C_&lt;name&gt;_CONFIG_DEFAULT –&gt; BFM default configuration constant</p></li>
</ul>
</div></blockquote>
<p>Additional types or constants can be added if needed.</p>
</div>
<div class="section" id="bfm-prerequisites">
<h3>BFM prerequisites<a class="headerlink" href="#bfm-prerequisites" title="Permalink to this headline">¶</a></h3>
<p>There are no firm restrictions of how to implement the BFM in order for the VVC to function, but if the VVC generated with the
vvc_generator script is to work out of the box, it is necessary to have some components in the BFM:</p>
<blockquote>
<div><ul class="simple">
<li><p>The BFM needs to be called &lt;name&gt;_bfm_pkg.vhd. If this is not the case, the package use clauses in each of the VVC files
needs to be altered.</p></li>
<li><p>The BFM needs to contain a bfm_config record type with an associated default constant. The generated VVC file assumes that
this bfm config type is called <strong>t_&lt;name&gt;_bfm_config</strong> and the constant is called C_&lt;NAME&gt;_BFM_CONFIG_DEFAULT. In order to
support the delay operation in the VVC executor the BFM config type will also need to have a parameter clock_period. If this
is not needed, the “INSERT_DELAY” case in the generated VVC can be removed.</p></li>
</ul>
</div></blockquote>
<p>A BFM skeleton that contains the necessary structure is created by the vvc_generator script, and can be used as a base for a BFM
that includes the necessary structure for the VVC to work out of the box.</p>
</div>
<div class="section" id="uvvm-framework-packages">
<h3>UVVM Framework Packages<a class="headerlink" href="#uvvm-framework-packages" title="Permalink to this headline">¶</a></h3>
<div class="section" id="td-target-support-pkg-vhd">
<h4>td_target_support_pkg.vhd<a class="headerlink" href="#td-target-support-pkg-vhd" title="Permalink to this headline">¶</a></h4>
<p>The UVVM VVC dedicated support package contains VVC support that is common for all VVCs, but needs to be compiled specifically
into each of the VVC libraries.</p>
<div class="section" id="target-record">
<h5>Target record<a class="headerlink" href="#target-record" title="Permalink to this headline">¶</a></h5>
<p>The target record type <strong>t_vvc_target_record</strong> is used to target a VVC command to a specific VVC implementation. This is needed
since many of the UVVM common commands are shared between all VVCs, e.g. await_completion() which is compiled into each VVC library.</p>
<p>For a sequencer with two VVCs, A and B, there must be a way of determining if await_completion is to be executed in VVC A or VVC B.
To resolve this, each VVC has a signal in their vvc_methods_pkg.vhd that is compiled into their own library. For VVC A and B this
signal will be called A_VVCT and B_VVCT. When await_completion(A_VVCT,…) is called from the sequencer, the compiler will
understand that this await_completion is called with target type library_a.t_vvc_target_record, which only complies with the
await_completion procedure in the VVC A library.</p>
<p>The td_target_support_pkg.vhd also contains a default value for the <strong>t_vvc_target_record</strong> type, and a function
set_vvc_target_defaults() for setting the VVC target based on the VVC name.</p>
</div>
<div class="section" id="string-methods">
<h5>String methods<a class="headerlink" href="#string-methods" title="Permalink to this headline">¶</a></h5>
<p>The package contains two string methods:</p>
<blockquote>
<div><ul class="simple">
<li><p>to_string(): This function converts a t_vvc_target_record, vvc_instance and vvc_channel into a string.</p></li>
<li><p>format_command_idx(): Function which encapsulates a command record index.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="send-command-to-vvc">
<h5>send_command_to_vvc<a class="headerlink" href="#send-command-to-vvc" title="Permalink to this headline">¶</a></h5>
<p>Sends command to VVC and waits for ACK or timeout.</p>
<blockquote>
<div><ul class="simple">
<li><p>Logs with ID_UVVM_SEND_CMD when sending to VVC.</p></li>
<li><p>Logs with ID_UVVM_CMD_ACK when ACK or timeout occurs.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="setting-the-command-field">
<h5>Setting the command field<a class="headerlink" href="#setting-the-command-field" title="Permalink to this headline">¶</a></h5>
<p>Sets target index and channel, and updates <em>shared_vvc_cmd</em> which is used to transport VVC commands from the central testbench
sequencer to VVC.</p>
</div>
</div>
<div class="section" id="td-vvc-entity-support-pkg-vhd">
<h4>td_vvc_entity_support_pkg.vhd<a class="headerlink" href="#td-vvc-entity-support-pkg-vhd" title="Permalink to this headline">¶</a></h4>
<p>The VVC support package contains procedures that are compiled into and used in the VVC. This includes initializers for the executor
and interpreter, and the interpreter procedures called interpreter_*, e.g. interpreter_await_completion(). For more information
about the interpreter_* procedures, please see <a class="reference internal" href="#vvc-framework-methods"><span class="std std-ref">Common VVC Methods</span></a>. For more information about the other methods in this
package, see <a class="reference internal" href="#vvc-framework-name-vvc"><span class="std std-ref">&lt;name&gt;_vvc.vhd</span></a>. In addition to the procedures, the td_vvc_entity_support_pkg.vhd also contains types
for VVC labels and executor results. The result array is also defined and its shared variable is instantiated in this package.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Disclaimer: This IP and any part thereof are provided “as is”, without warranty of any kind, express or implied, including but
not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or
otherwise, arising from, out of or in connection with this IP.</p>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="protected_types.html" class="btn btn-neutral float-right" title="Protected types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="optimized_rand.html" class="btn btn-neutral float-left" title="Optimized Randomization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, UVVM.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    

  <style>
         .wy-nav-content { max-width: none; }
  </style>



</body>
</html>